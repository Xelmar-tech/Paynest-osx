Compiling 104 files with Solc 0.8.17
Solc 0.8.17 finished in 4.76s
Compiler run successful!
Script ran successfully.

== Logs ==
  Deploying from: 0xDAef100C116E6D8358Ac3987e40b8c33F0b2730f
  PaymentsPluginSetup deployed at: 0x107537B35Ec8D98721bfAEF421346D10174263ba
  PaymentsPlugin repo deployed at: 0x6a0781E1AbBC3dA4783B8B6E9842E5D9aCf9D865
  PaynestDAOFactory deployed at: 0x69926a8A3a8E7555f1F672c45444b278cFF08b72
  
Deployment Summary
  ------------------
  Chain ID: 11155111
  PaymentsPluginSetup: 0x107537B35Ec8D98721bfAEF421346D10174263ba
  PaymentsPlugin Repo: 0x6a0781E1AbBC3dA4783B8B6E9842E5D9aCf9D865
  PaynestDAOFactory: 0x69926a8A3a8E7555f1F672c45444b278cFF08b72

## Setting up 1 EVM.

==========================

Chain 11155111

Estimated gas price: 2.135716916 gwei

Estimated total gas used for script: 8332313

Estimated amount required: 0.017795461823506708 ETH

==========================


==========================

ONCHAIN EXECUTION COMPLETE & SUCCESSFUL.
##
Start verification for (3) contracts
Start verifying contract `0x107537B35Ec8D98721bfAEF421346D10174263ba` deployed on sepolia
Compiler version: 0.8.17
Optimizations:    200

Submitting verification for [src/setup/PaymentsPluginSetup.sol:PaymentsPluginSetup] 0x107537B35Ec8D98721bfAEF421346D10174263ba.

Submitting verification for [src/setup/PaymentsPluginSetup.sol:PaymentsPluginSetup] 0x107537B35Ec8D98721bfAEF421346D10174263ba.

Submitting verification for [src/setup/PaymentsPluginSetup.sol:PaymentsPluginSetup] 0x107537B35Ec8D98721bfAEF421346D10174263ba.

Submitting verification for [src/setup/PaymentsPluginSetup.sol:PaymentsPluginSetup] 0x107537B35Ec8D98721bfAEF421346D10174263ba.

Submitting verification for [src/setup/PaymentsPluginSetup.sol:PaymentsPluginSetup] 0x107537B35Ec8D98721bfAEF421346D10174263ba.
[2m2025-02-15T18:45:48.040314Z[0m [31mERROR[0m [2mforge_verify::etherscan[0m[2m:[0m Failed to submit verification [3margs[0m[2m=[0m"{\"contractaddress\":\"0x107537b35ec8d98721bfaef421346d10174263ba\",\"sourceCode\":\"{\\\"language\\\":\\\"Solidity\\\",\\\"sources\\\":{\\\"src/setup/PaymentsPluginSetup.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: UNLICENSED\\\\npragma solidity ^0.8.17;\\\\n\\\\nimport {IPluginSetup} from \\\\\\\"@aragon/osx/framework/plugin/setup/IPluginSetup.sol\\\\\\\";\\\\nimport {PluginSetup} from \\\\\\\"@aragon/osx/framework/plugin/setup/PluginSetup.sol\\\\\\\";\\\\nimport {PaymentsPlugin} from \\\\\\\"../PaymentsPlugin.sol\\\\\\\";\\\\nimport {IDAO} from \\\\\\\"@aragon/osx/core/dao/IDAO.sol\\\\\\\";\\\\nimport {DAO} from \\\\\\\"@aragon/osx/core/dao/DAO.sol\\\\\\\";\\\\nimport {createProxyAndCall} from \\\\\\\"../util/proxy.sol\\\\\\\";\\\\nimport {PermissionLib} from \\\\\\\"@aragon/osx/core/permission/PermissionLib.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @title PaymentsPluginSetup\\\\n * @notice Setup contract for PaymentsPlugin. Deploys and initializes PaymentsPlugin with the required permissions.\\\\n */\\\\ncontract PaymentsPluginSetup is PluginSetup {\\\\n    address public immutable pluginImplementation;\\\\n\\\\n    constructor() {\\\\n        pluginImplementation = address(new PaymentsPlugin());\\\\n    }\\\\n\\\\n    function implementation() public view returns (address) {\\\\n        return pluginImplementation;\\\\n    }\\\\n\\\\n    /// @notice Prepares the installation of PaymentsPlugin.\\\\n    /// @param _dao The DAO address.\\\\n    /// @param _installParameters ABI encoded address[] of payment managers\\\\n    /// @return plugin The address of the deployed plugin proxy.\\\\n    /// @return preparedSetupData Setup data with permissions for payment management.\\\\n    function prepareInstallation(\\\\n        address _dao,\\\\n        bytes calldata _installParameters\\\\n    )\\\\n        external\\\\n        override\\\\n        returns (address plugin, PreparedSetupData memory preparedSetupData)\\\\n    {\\\\n        // Decode payment managers from installation parameters\\\\n        address[] memory paymentManagers = abi.decode(\\\\n            _installParameters,\\\\n            (address[])\\\\n        );\\\\n\\\\n        // Deploy plugin proxy and initialize it\\\\n        plugin = createProxyAndCall(\\\\n            implementation(),\\\\n            abi.encodeWithSelector(PaymentsPlugin.initialize.selector, _dao)\\\\n        );\\\\n\\\\n        // Calculate total number of permissions needed\\\\n        // 3 base permissions + 2 permissions per payment manager (create and edit)\\\\n        uint256 permissionLength = 3 + (paymentManagers.length * 2);\\\\n\\\\n        // Prepare permissions\\\\n        PermissionLib.MultiTargetPermission[]\\\\n            memory permissions = new PermissionLib.MultiTargetPermission[](\\\\n                permissionLength\\\\n            );\\\\n\\\\n        // Grant CREATE_PAYMENT_PERMISSION to the DAO\\\\n        permissions[0] = PermissionLib.MultiTargetPermission(\\\\n            PermissionLib.Operation.Grant,\\\\n            plugin, // where\\\\n            _dao, // who\\\\n            address(0), // condition\\\\n            PaymentsPlugin(plugin).CREATE_PAYMENT_PERMISSION_ID() // permissionId\\\\n        );\\\\n\\\\n        // Grant EDIT_PAYMENT_PERMISSION to the DAO\\\\n        permissions[1] = PermissionLib.MultiTargetPermission(\\\\n            PermissionLib.Operation.Grant,\\\\n            plugin, // where\\\\n            _dao, // who\\\\n            address(0), // condition\\\\n            PaymentsPlugin(plugin).EDIT_PAYMENT_PERMISSION_ID() // permissionId\\\\n        );\\\\n\\\\n        // Grant EXECUTE_PERMISSION on the DAO to the plugin\\\\n        permissions[2] = PermissionLib.MultiTargetPermission(\\\\n            PermissionLib.Operation.Grant,\\\\n            _dao, // where\\\\n            plugin, // who\\\\n            PermissionLib.NO_CONDITION,\\\\n            DAO(payable(_dao)).EXECUTE_PERMISSION_ID() // permissionId\\\\n        );\\\\n\\\\n        // Grant permissions to each payment manager\\\\n        for (uint256 i = 0; i < paymentManagers.length; i++) {\\\\n            // Grant CREATE_PAYMENT_PERMISSION\\\\n            permissions[3 + (i * 2)] = PermissionLib.MultiTargetPermission(\\\\n                PermissionLib.Operation.Grant,\\\\n                plugin, // where\\\\n                paymentManagers[i], // who\\\\n                address(0), // condition\\\\n                PaymentsPlugin(plugin).CREATE_PAYMENT_PERMISSION_ID() // permissionId\\\\n            );\\\\n\\\\n            // Grant EDIT_PAYMENT_PERMISSION\\\\n            permissions[3 + (i * 2) + 1] = PermissionLib.MultiTargetPermission(\\\\n                PermissionLib.Operation.Grant,\\\\n                plugin, // where\\\\n                paymentManagers[i], // who\\\\n                address(0), // condition\\\\n                PaymentsPlugin(plugin).EDIT_PAYMENT_PERMISSION_ID() // permissionId\\\\n            );\\\\n        }\\\\n\\\\n        preparedSetupData.helpers = new address[](0);\\\\n        preparedSetupData.permissions = permissions;\\\\n\\\\n        return (plugin, preparedSetupData);\\\\n    }\\\\n\\\\n    /// @notice Prepares the uninstallation of PaymentsPlugin.\\\\n    /// @dev Revokes all permissions granted on installation.\\\\n    function prepareUninstallation(\\\\n        address _dao,\\\\n        SetupPayload calldata _payload\\\\n    )\\\\n        external\\\\n        view\\\\n        override\\\\n        returns (PermissionLib.MultiTargetPermission[] memory permissions)\\\\n    {\\\\n        // Prepare permissions to be revoked\\\\n        permissions = new PermissionLib.MultiTargetPermission[](3);\\\\n\\\\n        // Revoke CREATE_PAYMENT_PERMISSION from DAO\\\\n        permissions[0] = PermissionLib.MultiTargetPermission(\\\\n            PermissionLib.Operation.Revoke,\\\\n            _payload.plugin, // where\\\\n            _dao, // who\\\\n            address(0), // condition\\\\n            PaymentsPlugin(_payload.plugin).CREATE_PAYMENT_PERMISSION_ID() // permissionId\\\\n        );\\\\n\\\\n        // Revoke EDIT_PAYMENT_PERMISSION from DAO\\\\n        permissions[1] = PermissionLib.MultiTargetPermission(\\\\n            PermissionLib.Operation.Revoke,\\\\n            _payload.plugin, // where\\\\n            _dao, // who\\\\n            address(0), // condition\\\\n            PaymentsPlugin(_payload.plugin).EDIT_PAYMENT_PERMISSION_ID() // permissionId\\\\n        );\\\\n\\\\n        // Revoke EXECUTE_PERMISSION from plugin\\\\n        permissions[2] = PermissionLib.MultiTargetPermission(\\\\n            PermissionLib.Operation.Revoke,\\\\n            _dao, // where\\\\n            _payload.plugin, // who\\\\n            PermissionLib.NO_CONDITION,\\\\n            DAO(payable(_dao)).EXECUTE_PERMISSION_ID() // permissionId\\\\n        );\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/framework/plugin/setup/IPluginSetup.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\nimport {PermissionLib} from \\\\\\\"../../../core/permission/PermissionLib.sol\\\\\\\";\\\\nimport {IDAO} from \\\\\\\"../../../core/dao/IDAO.sol\\\\\\\";\\\\n\\\\n/// @title IPluginSetup\\\\n/// @author Aragon Association - 2022-2023\\\\n/// @notice The interface required for a plugin setup contract to be consumed by the `PluginSetupProcessor` for plugin installations, updates, and uninstallations.\\\\ninterface IPluginSetup {\\\\n    /// @notice The data associated with a prepared setup.\\\\n    /// @param helpers The address array of helpers (contracts or EOAs) associated with this plugin version after the installation or update.\\\\n    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the installing or updating DAO.\\\\n    struct PreparedSetupData {\\\\n        address[] helpers;\\\\n        PermissionLib.MultiTargetPermission[] permissions;\\\\n    }\\\\n\\\\n    /// @notice The payload for plugin updates and uninstallations containing the existing contracts as well as optional data to be consumed by the plugin setup.\\\\n    /// @param plugin The address of the `Plugin`.\\\\n    /// @param currentHelpers The address array of all current helpers (contracts or EOAs) associated with the plugin to update from.\\\\n    /// @param data The bytes-encoded data containing the input parameters for the preparation of update/uninstall as specified in the corresponding ABI on the version's metadata.\\\\n    struct SetupPayload {\\\\n        address plugin;\\\\n        address[] currentHelpers;\\\\n        bytes data;\\\\n    }\\\\n\\\\n    /// @notice Prepares the installation of a plugin.\\\\n    /// @param _dao The address of the installing DAO.\\\\n    /// @param _data The bytes-encoded data containing the input parameters for the installation as specified in the plugin's build metadata JSON file.\\\\n    /// @return plugin The address of the `Plugin` contract being prepared for installation.\\\\n    /// @return preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\\\\n    function prepareInstallation(\\\\n        address _dao,\\\\n        bytes calldata _data\\\\n    ) external returns (address plugin, PreparedSetupData memory preparedSetupData);\\\\n\\\\n    /// @notice Prepares the update of a plugin.\\\\n    /// @param _dao The address of the updating DAO.\\\\n    /// @param _currentBuild The build number of the plugin to update from.\\\\n    /// @param _payload The relevant data necessary for the `prepareUpdate`. See above.\\\\n    /// @return initData The initialization data to be passed to upgradeable contracts when the update is applied in the `PluginSetupProcessor`.\\\\n    /// @return preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\\\\n    function prepareUpdate(\\\\n        address _dao,\\\\n        uint16 _currentBuild,\\\\n        SetupPayload calldata _payload\\\\n    ) external returns (bytes memory initData, PreparedSetupData memory preparedSetupData);\\\\n\\\\n    /// @notice Prepares the uninstallation of a plugin.\\\\n    /// @param _dao The address of the uninstalling DAO.\\\\n    /// @param _payload The relevant data necessary for the `prepareUninstallation`. See above.\\\\n    /// @return permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the uninstalling DAO.\\\\n    function prepareUninstallation(\\\\n        address _dao,\\\\n        SetupPayload calldata _payload\\\\n    ) external returns (PermissionLib.MultiTargetPermission[] memory permissions);\\\\n\\\\n    /// @notice Returns the plugin implementation address.\\\\n    /// @return The address of the plugin implementation contract.\\\\n    /// @dev The implementation can be instantiated via the `new` keyword, cloned via the minimal clones pattern (see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167)), or proxied via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\\\\n    function implementation() external view returns (address);\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/framework/plugin/setup/PluginSetup.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\nimport {ERC165} from \\\\\\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\\\\\";\\\\nimport {ERC165Checker} from \\\\\\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\\\\\";\\\\nimport {Clones} from \\\\\\\"@openzeppelin/contracts/proxy/Clones.sol\\\\\\\";\\\\n\\\\nimport {PermissionLib} from \\\\\\\"../../../core/permission/PermissionLib.sol\\\\\\\";\\\\nimport {createERC1967Proxy as createERC1967} from \\\\\\\"../../../utils/Proxy.sol\\\\\\\";\\\\nimport {IPluginSetup} from \\\\\\\"./IPluginSetup.sol\\\\\\\";\\\\n\\\\n/// @title PluginSetup\\\\n/// @author Aragon Association - 2022-2023\\\\n/// @notice An abstract contract that developers have to inherit from to write the setup of a plugin.\\\\nabstract contract PluginSetup is ERC165, IPluginSetup {\\\\n    /// @inheritdoc IPluginSetup\\\\n    function prepareUpdate(\\\\n        address _dao,\\\\n        uint16 _currentBuild,\\\\n        SetupPayload calldata _payload\\\\n    )\\\\n        external\\\\n        virtual\\\\n        override\\\\n        returns (bytes memory initData, PreparedSetupData memory preparedSetupData)\\\\n    {}\\\\n\\\\n    /// @notice A convenience function to create an [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy contract pointing to an implementation and being associated to a DAO.\\\\n    /// @param _implementation The address of the implementation contract to which the proxy is pointing to.\\\\n    /// @param _data The data to initialize the storage of the proxy contract.\\\\n    /// @return The address of the created proxy contract.\\\\n    function createERC1967Proxy(\\\\n        address _implementation,\\\\n        bytes memory _data\\\\n    ) internal returns (address) {\\\\n        return createERC1967(_implementation, _data);\\\\n    }\\\\n\\\\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\\\\n    /// @param _interfaceId The ID of the interface.\\\\n    /// @return Returns `true` if the interface is supported.\\\\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\\\n        return\\\\n            _interfaceId == type(IPluginSetup).interfaceId || super.supportsInterface(_interfaceId);\\\\n    }\\\\n}\\\\n\\\"},\\\"src/PaymentsPlugin.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: UNLICENSED\\\\npragma solidity ^0.8.17;\\\\n\\\\nimport {IDAO} from \\\\\\\"@aragon/osx/core/dao/IDAO.sol\\\\\\\";\\\\nimport {PluginUUPSUpgradeable} from \\\\\\\"@aragon/osx/core/plugin/PluginUUPSUpgradeable.sol\\\\\\\";\\\\nimport {IPayments} from \\\\\\\"./interfaces/IPayments.sol\\\\\\\";\\\\nimport {Errors} from \\\\\\\"./util/Errors.sol\\\\\\\";\\\\nimport {SafeERC20} from \\\\\\\"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\\\\\";\\\\nimport {IERC20} from \\\\\\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @title Payments Plugin\\\\n * @notice A plugin that manages payment schedules and streams, executing them through the DAO.\\\\n */\\\\ncontract PaymentsPlugin is PluginUUPSUpgradeable, IPayments, Errors {\\\\n    using SafeERC20 for IERC20;\\\\n\\\\n    bytes32 public constant CREATE_PAYMENT_PERMISSION_ID =\\\\n        keccak256(\\\\\\\"CREATE_PAYMENT_PERMISSION\\\\\\\");\\\\n\\\\n    bytes32 public constant EDIT_PAYMENT_PERMISSION_ID =\\\\n        keccak256(\\\\\\\"EDIT_PAYMENT_PERMISSION\\\\\\\");\\\\n\\\\n    bytes32 public constant EXECUTE_PAYMENT_PERMISSION_ID =\\\\n        keccak256(\\\\\\\"EXECUTE_PAYMENT_PERMISSION\\\\\\\");\\\\n\\\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\\\n\\\\n    mapping(string => address) private userDirectory;\\\\n    mapping(string => Schedule) private schedulePayment;\\\\n    mapping(string => Stream) private streamPayment;\\\\n\\\\n    /// @notice Initializes the plugin.\\\\n    /// @param _dao The DAO associated with this plugin.\\\\n    function initialize(IDAO _dao) external initializer {\\\\n        __PluginUUPSUpgradeable_init(_dao);\\\\n    }\\\\n\\\\n    function updateUserAddress(\\\\n        string calldata username,\\\\n        address userAddress\\\\n    ) external override {\\\\n        if (userDirectory[username] != msg.sender) {\\\\n            revert NotAuthorized();\\\\n        }\\\\n\\\\n        userDirectory[username] = userAddress;\\\\n\\\\n        emit UserAddressUpdated(username, userAddress);\\\\n    }\\\\n\\\\n    function getUserAddress(\\\\n        string calldata username\\\\n    ) external view override returns (address) {\\\\n        return userDirectory[username];\\\\n    }\\\\n\\\\n    function createSchedule(\\\\n        string calldata username,\\\\n        uint256 amount,\\\\n        address token,\\\\n        uint40 oneTimePayoutDate\\\\n    ) external override auth(CREATE_PAYMENT_PERMISSION_ID) {\\\\n        address userAddress = userDirectory[username];\\\\n\\\\n        if (userAddress == address(0)) {\\\\n            revert UserNotFound(username);\\\\n        }\\\\n\\\\n        if (amount == 0) revert InvalidAmount();\\\\n\\\\n        Schedule memory _schedule = schedulePayment[username];\\\\n        if (_schedule.active) revert ActivePayment(username);\\\\n\\\\n        uint40 _now = uint40(block.timestamp);\\\\n        bool isOneTime = oneTimePayoutDate > _now;\\\\n        uint40 nextPayout = isOneTime\\\\n            ? oneTimePayoutDate\\\\n            : (_now + uint40(30 days));\\\\n\\\\n        schedulePayment[username] = Schedule(\\\\n            token,\\\\n            nextPayout,\\\\n            isOneTime,\\\\n            true,\\\\n            amount\\\\n        );\\\\n        emit PaymentScheduleActive(username, token, nextPayout, amount);\\\\n    }\\\\n\\\\n    function claimUsername(string calldata username) external override {\\\\n        if (bytes(username).length == 0) {\\\\n            revert EmptyUsernameNotAllowed();\\\\n        }\\\\n\\\\n        if (userDirectory[username] != address(0)) {\\\\n            revert UsernameAlreadyClaimed(username);\\\\n        }\\\\n\\\\n        userDirectory[username] = msg.sender;\\\\n        emit UserAddressUpdated(username, msg.sender);\\\\n    }\\\\n\\\\n    function createStream(\\\\n        string calldata username,\\\\n        uint256 amount,\\\\n        address token,\\\\n        uint40 endStream\\\\n    ) external override auth(CREATE_PAYMENT_PERMISSION_ID) {\\\\n        address userAddress = userDirectory[username];\\\\n\\\\n        if (userAddress == address(0)) {\\\\n            revert UserNotFound(username);\\\\n        }\\\\n\\\\n        if (amount == 0) revert InvalidAmount();\\\\n\\\\n        Stream memory _stream = streamPayment[username];\\\\n        if (_stream.active) revert ActivePayment(username);\\\\n\\\\n        uint40 _now = uint40(block.timestamp);\\\\n        if (endStream <= _now) revert InvalidEndDate();\\\\n\\\\n        streamPayment[username] = Stream({\\\\n            token: token,\\\\n            startDate: _now,\\\\n            endDate: endStream,\\\\n            active: true,\\\\n            amount: amount,\\\\n            lastPayout: _now\\\\n        });\\\\n        emit StreamActive(username, token, _now, endStream, amount);\\\\n    }\\\\n\\\\n    function executePayment(\\\\n        string calldata username\\\\n    ) external auth(EXECUTE_PAYMENT_PERMISSION_ID) {\\\\n        Schedule memory schedule = schedulePayment[username];\\\\n        if (schedule.active && schedule.nextPayout <= block.timestamp) {\\\\n            address recipient = userDirectory[username];\\\\n            if (recipient == address(0)) revert UserNotFound(username);\\\\n\\\\n            // Create action to be executed by the DAO\\\\n            IDAO.Action[] memory actions = new IDAO.Action[](1);\\\\n\\\\n            if (schedule.token == ETH) {\\\\n                actions[0] = IDAO.Action({\\\\n                    to: recipient,\\\\n                    value: schedule.amount,\\\\n                    data: \\\\\\\"\\\\\\\"\\\\n                });\\\\n            } else {\\\\n                actions[0] = IDAO.Action({\\\\n                    to: schedule.token,\\\\n                    value: 0,\\\\n                    data: abi.encodeCall(\\\\n                        IERC20.transfer,\\\\n                        (recipient, schedule.amount)\\\\n                    )\\\\n                });\\\\n            }\\\\n\\\\n            // Execute the payment through the DAO\\\\n            dao().execute({\\\\n                _callId: bytes32(0),\\\\n                _actions: actions,\\\\n                _allowFailureMap: 0\\\\n            });\\\\n\\\\n            if (schedule.isOneTime) {\\\\n                schedule.active = false;\\\\n            } else {\\\\n                schedule.nextPayout = uint40(block.timestamp + 30 days);\\\\n            }\\\\n            schedulePayment[username] = schedule;\\\\n\\\\n            emit PaymentExecuted(username, schedule.token, schedule.amount);\\\\n        }\\\\n    }\\\\n\\\\n    function executeStream(\\\\n        string calldata username\\\\n    ) external auth(EXECUTE_PAYMENT_PERMISSION_ID) {\\\\n        Stream memory stream = streamPayment[username];\\\\n        if (!stream.active) revert NoActivePayment(username);\\\\n\\\\n        uint40 _now = uint40(block.timestamp);\\\\n        if (_now > stream.endDate) {\\\\n            stream.active = false;\\\\n            streamPayment[username] = stream;\\\\n            return;\\\\n        }\\\\n\\\\n        address recipient = userDirectory[username];\\\\n        if (recipient == address(0)) revert UserNotFound(username);\\\\n\\\\n        uint256 elapsedTime = _now - stream.lastPayout;\\\\n        uint256 totalDuration = stream.endDate - stream.startDate;\\\\n        uint256 amount = (stream.amount * elapsedTime) / totalDuration;\\\\n\\\\n        if (amount > 0) {\\\\n            // Create action to be executed by the DAO\\\\n            IDAO.Action[] memory actions = new IDAO.Action[](1);\\\\n\\\\n            if (stream.token == ETH) {\\\\n                actions[0] = IDAO.Action({\\\\n                    to: recipient,\\\\n                    value: amount,\\\\n                    data: \\\\\\\"\\\\\\\"\\\\n                });\\\\n            } else {\\\\n                actions[0] = IDAO.Action({\\\\n                    to: stream.token,\\\\n                    value: 0,\\\\n                    data: abi.encodeCall(IERC20.transfer, (recipient, amount))\\\\n                });\\\\n            }\\\\n\\\\n            // Execute the payment through the DAO\\\\n            dao().execute({\\\\n                _callId: bytes32(0),\\\\n                _actions: actions,\\\\n                _allowFailureMap: 0\\\\n            });\\\\n\\\\n            stream.lastPayout = _now;\\\\n            streamPayment[username] = stream;\\\\n\\\\n            emit StreamPaymentExecuted(username, stream.token, amount);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Retrieves the current stream details for a user.\\\\n     * @param username The username to query stream against.\\\\n     * @return stream The stream information.\\\\n     */\\\\n    function getStream(\\\\n        string calldata username\\\\n    ) external view override returns (Stream memory) {\\\\n        return streamPayment[username];\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Retrieves the current schedule payment details for a user.\\\\n     * @param username The username to query schedule against.\\\\n     * @return schedule The schedule information.\\\\n     */\\\\n    function getSchedule(\\\\n        string calldata username\\\\n    ) external view override returns (Schedule memory) {\\\\n        return schedulePayment[username];\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/dao/IDAO.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\n/// @title IDAO\\\\n/// @author Aragon Association - 2022-2023\\\\n/// @notice The interface required for DAOs within the Aragon App DAO framework.\\\\ninterface IDAO {\\\\n    /// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\\\\n    /// @param to The address to call.\\\\n    /// @param value The native token value to be sent with the call.\\\\n    /// @param data The bytes-encoded function selector and calldata for the call.\\\\n    struct Action {\\\\n        address to;\\\\n        uint256 value;\\\\n        bytes data;\\\\n    }\\\\n\\\\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\\\\n    /// @param _where The address of the contract.\\\\n    /// @param _who The address of a EOA or contract to give the permissions.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\\\\n    /// @return Returns true if the address has permission, false if not.\\\\n    function hasPermission(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId,\\\\n        bytes memory _data\\\\n    ) external view returns (bool);\\\\n\\\\n    /// @notice Updates the DAO metadata (e.g., an IPFS hash).\\\\n    /// @param _metadata The IPFS hash of the new metadata object.\\\\n    function setMetadata(bytes calldata _metadata) external;\\\\n\\\\n    /// @notice Emitted when the DAO metadata is updated.\\\\n    /// @param metadata The IPFS hash of the new metadata object.\\\\n    event MetadataSet(bytes metadata);\\\\n\\\\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\\\\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\\\\n    /// @param _actions The array of actions.\\\\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\\\\n    /// @return The array of results obtained from the executed actions in `bytes`.\\\\n    /// @return The resulting failure map containing the actions have actually failed.\\\\n    function execute(\\\\n        bytes32 _callId,\\\\n        Action[] memory _actions,\\\\n        uint256 _allowFailureMap\\\\n    ) external returns (bytes[] memory, uint256);\\\\n\\\\n    /// @notice Emitted when a proposal is executed.\\\\n    /// @param actor The address of the caller.\\\\n    /// @param callId The ID of the call.\\\\n    /// @param actions The array of actions executed.\\\\n    /// @param allowFailureMap The allow failure map encoding which actions are allowed to fail.\\\\n    /// @param failureMap The failure map encoding which actions have failed.\\\\n    /// @param execResults The array with the results of the executed actions.\\\\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function. A `Plugin` implementation can use it, for example, as a nonce.\\\\n    event Executed(\\\\n        address indexed actor,\\\\n        bytes32 callId,\\\\n        Action[] actions,\\\\n        uint256 allowFailureMap,\\\\n        uint256 failureMap,\\\\n        bytes[] execResults\\\\n    );\\\\n\\\\n    /// @notice Emitted when a standard callback is registered.\\\\n    /// @param interfaceId The ID of the interface.\\\\n    /// @param callbackSelector The selector of the callback function.\\\\n    /// @param magicNumber The magic number to be registered for the callback function selector.\\\\n    event StandardCallbackRegistered(\\\\n        bytes4 interfaceId,\\\\n        bytes4 callbackSelector,\\\\n        bytes4 magicNumber\\\\n    );\\\\n\\\\n    /// @notice Deposits (native) tokens to the DAO contract with a reference string.\\\\n    /// @param _token The address of the token or address(0) in case of the native token.\\\\n    /// @param _amount The amount of tokens to deposit.\\\\n    /// @param _reference The reference describing the deposit reason.\\\\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable;\\\\n\\\\n    /// @notice Emitted when a token deposit has been made to the DAO.\\\\n    /// @param sender The address of the sender.\\\\n    /// @param token The address of the deposited token.\\\\n    /// @param amount The amount of tokens deposited.\\\\n    /// @param _reference The reference describing the deposit reason.\\\\n    event Deposited(\\\\n        address indexed sender,\\\\n        address indexed token,\\\\n        uint256 amount,\\\\n        string _reference\\\\n    );\\\\n\\\\n    /// @notice Emitted when a native token deposit has been made to the DAO.\\\\n    /// @dev This event is intended to be emitted in the `receive` function and is therefore bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\\\\n    /// @param sender The address of the sender.\\\\n    /// @param amount The amount of native tokens deposited.\\\\n    event NativeTokenDeposited(address sender, uint256 amount);\\\\n\\\\n    /// @notice Setter for the trusted forwarder verifying the meta transaction.\\\\n    /// @param _trustedForwarder The trusted forwarder address.\\\\n    function setTrustedForwarder(address _trustedForwarder) external;\\\\n\\\\n    /// @notice Getter for the trusted forwarder verifying the meta transaction.\\\\n    /// @return The trusted forwarder address.\\\\n    function getTrustedForwarder() external view returns (address);\\\\n\\\\n    /// @notice Emitted when a new TrustedForwarder is set on the DAO.\\\\n    /// @param forwarder the new forwarder address.\\\\n    event TrustedForwarderSet(address forwarder);\\\\n\\\\n    /// @notice Setter for the [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\\\\n    /// @param _signatureValidator The address of the signature validator.\\\\n    function setSignatureValidator(address _signatureValidator) external;\\\\n\\\\n    /// @notice Emitted when the signature validator address is updated.\\\\n    /// @param signatureValidator The address of the signature validator.\\\\n    event SignatureValidatorSet(address signatureValidator);\\\\n\\\\n    /// @notice Checks whether a signature is valid for the provided hash by forwarding the call to the set [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\\\\n    /// @param _hash The hash of the data to be signed.\\\\n    /// @param _signature The signature byte array associated with `_hash`.\\\\n    /// @return Returns the `bytes4` magic value `0x1626ba7e` if the signature is valid.\\\\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external returns (bytes4);\\\\n\\\\n    /// @notice Registers an ERC standard having a callback by registering its [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.\\\\n    /// @param _interfaceId The ID of the interface.\\\\n    /// @param _callbackSelector The selector of the callback function.\\\\n    /// @param _magicNumber The magic number to be registered for the function signature.\\\\n    function registerStandardCallback(\\\\n        bytes4 _interfaceId,\\\\n        bytes4 _callbackSelector,\\\\n        bytes4 _magicNumber\\\\n    ) external;\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/dao/DAO.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity 0.8.17;\\\\n\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\\\\\";\\\\n\\\\nimport {IProtocolVersion} from \\\\\\\"../../utils/protocol/IProtocolVersion.sol\\\\\\\";\\\\nimport {ProtocolVersion} from \\\\\\\"../../utils/protocol/ProtocolVersion.sol\\\\\\\";\\\\nimport {PermissionManager} from \\\\\\\"../permission/PermissionManager.sol\\\\\\\";\\\\nimport {CallbackHandler} from \\\\\\\"../utils/CallbackHandler.sol\\\\\\\";\\\\nimport {hasBit, flipBit} from \\\\\\\"../utils/BitMap.sol\\\\\\\";\\\\nimport {IEIP4824} from \\\\\\\"./IEIP4824.sol\\\\\\\";\\\\nimport {IDAO} from \\\\\\\"./IDAO.sol\\\\\\\";\\\\n\\\\n/// @title DAO\\\\n/// @author Aragon Association - 2021-2023\\\\n/// @notice This contract is the entry point to the Aragon DAO framework and provides our users a simple and easy to use public interface.\\\\n/// @dev Public API of the Aragon DAO framework.\\\\ncontract DAO is\\\\n    IEIP4824,\\\\n    Initializable,\\\\n    IERC1271,\\\\n    ERC165StorageUpgradeable,\\\\n    IDAO,\\\\n    UUPSUpgradeable,\\\\n    ProtocolVersion,\\\\n    PermissionManager,\\\\n    CallbackHandler\\\\n{\\\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\\\n    using AddressUpgradeable for address;\\\\n\\\\n    /// @notice The ID of the permission required to call the `execute` function.\\\\n    bytes32 public constant EXECUTE_PERMISSION_ID = keccak256(\\\\\\\"EXECUTE_PERMISSION\\\\\\\");\\\\n\\\\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\\\\n    bytes32 public constant UPGRADE_DAO_PERMISSION_ID = keccak256(\\\\\\\"UPGRADE_DAO_PERMISSION\\\\\\\");\\\\n\\\\n    /// @notice The ID of the permission required to call the `setMetadata` function.\\\\n    bytes32 public constant SET_METADATA_PERMISSION_ID = keccak256(\\\\\\\"SET_METADATA_PERMISSION\\\\\\\");\\\\n\\\\n    /// @notice The ID of the permission required to call the `setTrustedForwarder` function.\\\\n    bytes32 public constant SET_TRUSTED_FORWARDER_PERMISSION_ID =\\\\n        keccak256(\\\\\\\"SET_TRUSTED_FORWARDER_PERMISSION\\\\\\\");\\\\n\\\\n    /// @notice The ID of the permission required to call the `setSignatureValidator` function.\\\\n    bytes32 public constant SET_SIGNATURE_VALIDATOR_PERMISSION_ID =\\\\n        keccak256(\\\\\\\"SET_SIGNATURE_VALIDATOR_PERMISSION\\\\\\\");\\\\n\\\\n    /// @notice The ID of the permission required to call the `registerStandardCallback` function.\\\\n    bytes32 public constant REGISTER_STANDARD_CALLBACK_PERMISSION_ID =\\\\n        keccak256(\\\\\\\"REGISTER_STANDARD_CALLBACK_PERMISSION\\\\\\\");\\\\n\\\\n    /// @notice The internal constant storing the maximal action array length.\\\\n    uint256 internal constant MAX_ACTIONS = 256;\\\\n\\\\n    /// @notice The first out of two values to which the `_reentrancyStatus` state variable (used by the `nonReentrant` modifier) can be set inidicating that a function was not entered.\\\\n    uint256 private constant _NOT_ENTERED = 1;\\\\n\\\\n    /// @notice The second out of two values to which the `_reentrancyStatus` state variable (used by the `nonReentrant` modifier) can be set inidicating that a function was entered.\\\\n    uint256 private constant _ENTERED = 2;\\\\n\\\\n    /// @notice The [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\\\\n    /// @dev Added in v1.0.0.\\\\n    IERC1271 public signatureValidator;\\\\n\\\\n    /// @notice The address of the trusted forwarder verifying meta transactions.\\\\n    /// @dev Added in v1.0.0.\\\\n    address private trustedForwarder;\\\\n\\\\n    /// @notice The [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO URI.\\\\n    /// @dev Added in v1.0.0.\\\\n    string private _daoURI;\\\\n\\\\n    /// @notice The state variable for the reentrancy guard of the `execute` function.\\\\n    /// @dev Added in v1.3.0. The variable can be of value `_NOT_ENTERED = 1` or `_ENTERED = 2` in usage and is initialized with `_NOT_ENTERED`.\\\\n    uint256 private _reentrancyStatus;\\\\n\\\\n    /// @notice Thrown if a call is reentrant.\\\\n    error ReentrantCall();\\\\n\\\\n    /// @notice Thrown if the action array length is larger than `MAX_ACTIONS`.\\\\n    error TooManyActions();\\\\n\\\\n    /// @notice Thrown if action execution has failed.\\\\n    /// @param index The index of the action in the action array that failed.\\\\n    error ActionFailed(uint256 index);\\\\n\\\\n    /// @notice Thrown if an action has insufficent gas left.\\\\n    error InsufficientGas();\\\\n\\\\n    /// @notice Thrown if the deposit amount is zero.\\\\n    error ZeroAmount();\\\\n\\\\n    /// @notice Thrown if there is a mismatch between the expected and actually deposited amount of native tokens.\\\\n    /// @param expected The expected native token amount.\\\\n    /// @param actual The actual native token amount deposited.\\\\n    error NativeTokenDepositAmountMismatch(uint256 expected, uint256 actual);\\\\n\\\\n    /// @notice Thrown if an upgrade is not supported from a specific protocol version .\\\\n    error ProtocolVersionUpgradeNotSupported(uint8[3] protocolVersion);\\\\n\\\\n    /// @notice Emitted when a new DAO URI is set.\\\\n    /// @param daoURI The new URI.\\\\n    event NewURI(string daoURI);\\\\n\\\\n    /// @notice A modifier to protect a function from calling itself, directly or indirectly (reentrancy).\\\\n    /// @dev Currently, this modifier is only applied to the `execute()` function. If this is used multiple times, private `_beforeNonReentrant()` and `_afterNonReentrant()` functions should be created to prevent code duplication.\\\\n    modifier nonReentrant() {\\\\n        if (_reentrancyStatus == _ENTERED) {\\\\n            revert ReentrantCall();\\\\n        }\\\\n        _reentrancyStatus = _ENTERED;\\\\n\\\\n        _;\\\\n\\\\n        _reentrancyStatus = _NOT_ENTERED;\\\\n    }\\\\n\\\\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\\\\n    constructor() {\\\\n        _disableInitializers();\\\\n    }\\\\n\\\\n    /// @notice Initializes the DAO by\\\\n    /// - setting the reentrancy status variable to `_NOT_ENTERED`\\\\n    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID\\\\n    /// - setting the trusted forwarder for meta transactions\\\\n    /// - giving the `ROOT_PERMISSION_ID` permission to the initial owner (that should be revoked and transferred to the DAO after setup).\\\\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\\\\n    /// @param _metadata IPFS hash that points to all the metadata (logo, description, tags, etc.) of a DAO.\\\\n    /// @param _initialOwner The initial owner of the DAO having the `ROOT_PERMISSION_ID` permission.\\\\n    /// @param _trustedForwarder The trusted forwarder responsible for verifying meta transactions.\\\\n    /// @param daoURI_ The DAO URI required to support [ERC-4824](https://eips.ethereum.org/EIPS/eip-4824).\\\\n    function initialize(\\\\n        bytes calldata _metadata,\\\\n        address _initialOwner,\\\\n        address _trustedForwarder,\\\\n        string calldata daoURI_\\\\n    ) external reinitializer(2) {\\\\n        _reentrancyStatus = _NOT_ENTERED; // added in v1.3.0\\\\n\\\\n        _registerInterface(type(IDAO).interfaceId);\\\\n        _registerInterface(type(IERC1271).interfaceId);\\\\n        _registerInterface(type(IEIP4824).interfaceId);\\\\n        _registerInterface(type(IProtocolVersion).interfaceId); // added in v1.3.0\\\\n        _registerTokenInterfaces();\\\\n\\\\n        _setMetadata(_metadata);\\\\n        _setTrustedForwarder(_trustedForwarder);\\\\n        _setDaoURI(daoURI_);\\\\n        __PermissionManager_init(_initialOwner);\\\\n    }\\\\n\\\\n    /// @notice Initializes the DAO after an upgrade from a previous protocol version.\\\\n    /// @param _previousProtocolVersion The semantic protocol version number of the previous DAO implementation contract this upgrade is transitioning from.\\\\n    /// @param _initData The initialization data to be passed to via `upgradeToAndCall` (see [ERC-1967](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Upgrade)).\\\\n    function initializeFrom(\\\\n        uint8[3] calldata _previousProtocolVersion,\\\\n        bytes calldata _initData\\\\n    ) external reinitializer(2) {\\\\n        _initData; // Silences the unused function parameter warning.\\\\n\\\\n        // Check that the contract is not upgrading from a different major release.\\\\n        if (_previousProtocolVersion[0] != 1) {\\\\n            revert ProtocolVersionUpgradeNotSupported(_previousProtocolVersion);\\\\n        }\\\\n\\\\n        // Initialize `_reentrancyStatus` that was added in v1.3.0.\\\\n        // Register Interface `ProtocolVersion` that was added in v1.3.0.\\\\n        if (_previousProtocolVersion[1] <= 2) {\\\\n            _reentrancyStatus = _NOT_ENTERED;\\\\n            _registerInterface(type(IProtocolVersion).interfaceId);\\\\n        }\\\\n    }\\\\n\\\\n    /// @inheritdoc PermissionManager\\\\n    function isPermissionRestrictedForAnyAddr(\\\\n        bytes32 _permissionId\\\\n    ) internal pure override returns (bool) {\\\\n        return\\\\n            _permissionId == EXECUTE_PERMISSION_ID ||\\\\n            _permissionId == UPGRADE_DAO_PERMISSION_ID ||\\\\n            _permissionId == SET_METADATA_PERMISSION_ID ||\\\\n            _permissionId == SET_TRUSTED_FORWARDER_PERMISSION_ID ||\\\\n            _permissionId == SET_SIGNATURE_VALIDATOR_PERMISSION_ID ||\\\\n            _permissionId == REGISTER_STANDARD_CALLBACK_PERMISSION_ID;\\\\n    }\\\\n\\\\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\\\\n    /// @dev The caller must have the `UPGRADE_DAO_PERMISSION_ID` permission.\\\\n    function _authorizeUpgrade(address) internal virtual override auth(UPGRADE_DAO_PERMISSION_ID) {}\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function setTrustedForwarder(\\\\n        address _newTrustedForwarder\\\\n    ) external override auth(SET_TRUSTED_FORWARDER_PERMISSION_ID) {\\\\n        _setTrustedForwarder(_newTrustedForwarder);\\\\n    }\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function getTrustedForwarder() external view virtual override returns (address) {\\\\n        return trustedForwarder;\\\\n    }\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function hasPermission(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId,\\\\n        bytes memory _data\\\\n    ) external view override returns (bool) {\\\\n        return isGranted(_where, _who, _permissionId, _data);\\\\n    }\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function setMetadata(\\\\n        bytes calldata _metadata\\\\n    ) external override auth(SET_METADATA_PERMISSION_ID) {\\\\n        _setMetadata(_metadata);\\\\n    }\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function execute(\\\\n        bytes32 _callId,\\\\n        Action[] calldata _actions,\\\\n        uint256 _allowFailureMap\\\\n    )\\\\n        external\\\\n        override\\\\n        nonReentrant\\\\n        auth(EXECUTE_PERMISSION_ID)\\\\n        returns (bytes[] memory execResults, uint256 failureMap)\\\\n    {\\\\n        // Check that the action array length is within bounds.\\\\n        if (_actions.length > MAX_ACTIONS) {\\\\n            revert TooManyActions();\\\\n        }\\\\n\\\\n        execResults = new bytes[](_actions.length);\\\\n\\\\n        uint256 gasBefore;\\\\n        uint256 gasAfter;\\\\n\\\\n        for (uint256 i = 0; i < _actions.length; ) {\\\\n            gasBefore = gasleft();\\\\n\\\\n            (bool success, bytes memory result) = _actions[i].to.call{value: _actions[i].value}(\\\\n                _actions[i].data\\\\n            );\\\\n            gasAfter = gasleft();\\\\n\\\\n            // Check if failure is allowed\\\\n            if (!hasBit(_allowFailureMap, uint8(i))) {\\\\n                // Check if the call failed.\\\\n                if (!success) {\\\\n                    revert ActionFailed(i);\\\\n                }\\\\n            } else {\\\\n                // Check if the call failed.\\\\n                if (!success) {\\\\n                    // Make sure that the action call did not fail because 63/64 of `gasleft()` was insufficient to execute the external call `.to.call` (see [ERC-150](https://eips.ethereum.org/EIPS/eip-150)).\\\\n                    // In specific scenarios, i.e. proposal execution where the last action in the action array is allowed to fail, the account calling `execute` could force-fail this action by setting a gas limit\\\\n                    // where 63/64 is insufficient causing the `.to.call` to fail, but where the remaining 1/64 gas are sufficient to successfully finish the `execute` call.\\\\n                    if (gasAfter < gasBefore / 64) {\\\\n                        revert InsufficientGas();\\\\n                    }\\\\n\\\\n                    // Store that this action failed.\\\\n                    failureMap = flipBit(failureMap, uint8(i));\\\\n                }\\\\n            }\\\\n\\\\n            execResults[i] = result;\\\\n\\\\n            unchecked {\\\\n                ++i;\\\\n            }\\\\n        }\\\\n\\\\n        emit Executed({\\\\n            actor: msg.sender,\\\\n            callId: _callId,\\\\n            actions: _actions,\\\\n            allowFailureMap: _allowFailureMap,\\\\n            failureMap: failureMap,\\\\n            execResults: execResults\\\\n        });\\\\n    }\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function deposit(\\\\n        address _token,\\\\n        uint256 _amount,\\\\n        string calldata _reference\\\\n    ) external payable override {\\\\n        if (_amount == 0) revert ZeroAmount();\\\\n\\\\n        if (_token == address(0)) {\\\\n            if (msg.value != _amount)\\\\n                revert NativeTokenDepositAmountMismatch({expected: _amount, actual: msg.value});\\\\n        } else {\\\\n            if (msg.value != 0)\\\\n                revert NativeTokenDepositAmountMismatch({expected: 0, actual: msg.value});\\\\n\\\\n            IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\\\\n        }\\\\n\\\\n        emit Deposited(msg.sender, _token, _amount, _reference);\\\\n    }\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function setSignatureValidator(\\\\n        address _signatureValidator\\\\n    ) external override auth(SET_SIGNATURE_VALIDATOR_PERMISSION_ID) {\\\\n        signatureValidator = IERC1271(_signatureValidator);\\\\n\\\\n        emit SignatureValidatorSet({signatureValidator: _signatureValidator});\\\\n    }\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function isValidSignature(\\\\n        bytes32 _hash,\\\\n        bytes memory _signature\\\\n    ) external view override(IDAO, IERC1271) returns (bytes4) {\\\\n        if (address(signatureValidator) == address(0)) {\\\\n            // Return the invalid magic number\\\\n            return bytes4(0);\\\\n        }\\\\n        // Forward the call to the set signature validator contract\\\\n        return signatureValidator.isValidSignature(_hash, _signature);\\\\n    }\\\\n\\\\n    /// @notice Emits the `NativeTokenDeposited` event to track native token deposits that weren't made via the deposit method.\\\\n    /// @dev This call is bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\\\\n    /// Gas cost increases in future hard forks might break this function. As an alternative, [ERC-2930](https://eips.ethereum.org/EIPS/eip-2930)-type transactions using access lists can be employed.\\\\n    receive() external payable {\\\\n        emit NativeTokenDeposited(msg.sender, msg.value);\\\\n    }\\\\n\\\\n    /// @notice Fallback to handle future versions of the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) standard.\\\\n    /// @param _input An alias being equivalent to `msg.data`. This feature of the fallback function was introduced with the [solidity compiler version 0.7.6](https://github.com/ethereum/solidity/releases/tag/v0.7.6)\\\\n    /// @return The magic number registered for the function selector triggering the fallback.\\\\n    fallback(bytes calldata _input) external returns (bytes memory) {\\\\n        bytes4 magicNumber = _handleCallback(msg.sig, _input);\\\\n        return abi.encode(magicNumber);\\\\n    }\\\\n\\\\n    /// @notice Emits the MetadataSet event if new metadata is set.\\\\n    /// @param _metadata Hash of the IPFS metadata object.\\\\n    function _setMetadata(bytes calldata _metadata) internal {\\\\n        emit MetadataSet(_metadata);\\\\n    }\\\\n\\\\n    /// @notice Sets the trusted forwarder on the DAO and emits the associated event.\\\\n    /// @param _trustedForwarder The trusted forwarder address.\\\\n    function _setTrustedForwarder(address _trustedForwarder) internal {\\\\n        trustedForwarder = _trustedForwarder;\\\\n\\\\n        emit TrustedForwarderSet(_trustedForwarder);\\\\n    }\\\\n\\\\n    /// @notice Registers the [ERC-721](https://eips.ethereum.org/EIPS/eip-721) and [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155) interfaces and callbacks.\\\\n    function _registerTokenInterfaces() private {\\\\n        _registerInterface(type(IERC721ReceiverUpgradeable).interfaceId);\\\\n        _registerInterface(type(IERC1155ReceiverUpgradeable).interfaceId);\\\\n\\\\n        _registerCallback(\\\\n            IERC721ReceiverUpgradeable.onERC721Received.selector,\\\\n            IERC721ReceiverUpgradeable.onERC721Received.selector\\\\n        );\\\\n        _registerCallback(\\\\n            IERC1155ReceiverUpgradeable.onERC1155Received.selector,\\\\n            IERC1155ReceiverUpgradeable.onERC1155Received.selector\\\\n        );\\\\n        _registerCallback(\\\\n            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector,\\\\n            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector\\\\n        );\\\\n    }\\\\n\\\\n    /// @inheritdoc IDAO\\\\n    function registerStandardCallback(\\\\n        bytes4 _interfaceId,\\\\n        bytes4 _callbackSelector,\\\\n        bytes4 _magicNumber\\\\n    ) external override auth(REGISTER_STANDARD_CALLBACK_PERMISSION_ID) {\\\\n        _registerInterface(_interfaceId);\\\\n        _registerCallback(_callbackSelector, _magicNumber);\\\\n        emit StandardCallbackRegistered(_interfaceId, _callbackSelector, _magicNumber);\\\\n    }\\\\n\\\\n    /// @inheritdoc IEIP4824\\\\n    function daoURI() external view returns (string memory) {\\\\n        return _daoURI;\\\\n    }\\\\n\\\\n    /// @notice Updates the set DAO URI to a new value.\\\\n    /// @param newDaoURI The new DAO URI to be set.\\\\n    function setDaoURI(string calldata newDaoURI) external auth(SET_METADATA_PERMISSION_ID) {\\\\n        _setDaoURI(newDaoURI);\\\\n    }\\\\n\\\\n    /// @notice Sets the new [ERC-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO URI and emits the associated event.\\\\n    /// @param daoURI_ The new DAO URI.\\\\n    function _setDaoURI(string calldata daoURI_) internal {\\\\n        _daoURI = daoURI_;\\\\n\\\\n        emit NewURI(daoURI_);\\\\n    }\\\\n\\\\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\\\\n    uint256[46] private __gap;\\\\n}\\\\n\\\"},\\\"src/util/proxy.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: UNLICENSED\\\\npragma solidity ^0.8.17;\\\\n\\\\nimport {ERC1967Proxy} from \\\\\\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\\\\\";\\\\n\\\\nfunction createProxyAndCall(\\\\n    address logic,\\\\n    bytes memory data\\\\n) returns (address) {\\\\n    return address(new ERC1967Proxy(logic, data));\\\\n}\\\\n\\\\nfunction createSaltedProxyAndCall(\\\\n    address logic,\\\\n    bytes memory data,\\\\n    bytes32 salt\\\\n) returns (address) {\\\\n    return address(new ERC1967Proxy{salt: salt}(logic, data));\\\\n}\\\\n\\\\nfunction predictProxyAddress(\\\\n    address factory,\\\\n    bytes32 salt,\\\\n    address logic,\\\\n    bytes memory data\\\\n) pure returns (address predictedAddress) {\\\\n    predictedAddress = address(\\\\n        uint160(\\\\n            uint256(\\\\n                keccak256(\\\\n                    abi.encodePacked(\\\\n                        bytes1(0xff),\\\\n                        factory,\\\\n                        salt,\\\\n                        keccak256(\\\\n                            abi.encodePacked(\\\\n                                type(ERC1967Proxy).creationCode,\\\\n                                abi.encode(logic, data)\\\\n                            )\\\\n                        )\\\\n                    )\\\\n                )\\\\n            )\\\\n        )\\\\n    );\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/permission/PermissionLib.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\n/// @title PermissionLib\\\\n/// @author Aragon Association - 2021-2023\\\\n/// @notice A library containing objects for permission processing.\\\\nlibrary PermissionLib {\\\\n    /// @notice A constant expressing that no condition is applied to a permission.\\\\n    address public constant NO_CONDITION = address(0);\\\\n\\\\n    /// @notice The types of permission operations available in the `PermissionManager`.\\\\n    /// @param Grant The grant operation setting a permission without a condition.\\\\n    /// @param Revoke The revoke operation removing a permission (that was granted with or without a condition).\\\\n    /// @param GrantWithCondition The grant operation setting a permission with a condition.\\\\n    enum Operation {\\\\n        Grant,\\\\n        Revoke,\\\\n        GrantWithCondition\\\\n    }\\\\n\\\\n    /// @notice A struct containing the information for a permission to be applied on a single target contract without a condition.\\\\n    /// @param operation The permission operation type.\\\\n    /// @param who The address (EOA or contract) receiving the permission.\\\\n    /// @param permissionId The permission identifier.\\\\n    struct SingleTargetPermission {\\\\n        Operation operation;\\\\n        address who;\\\\n        bytes32 permissionId;\\\\n    }\\\\n\\\\n    /// @notice A struct containing the information for a permission to be applied on multiple target contracts, optionally, with a condition.\\\\n    /// @param operation The permission operation type.\\\\n    /// @param where The address of the target contract for which `who` receives permission.\\\\n    /// @param who The address (EOA or contract) receiving the permission.\\\\n    /// @param condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\\\\n    /// @param permissionId The permission identifier.\\\\n    struct MultiTargetPermission {\\\\n        Operation operation;\\\\n        address where;\\\\n        address who;\\\\n        address condition;\\\\n        bytes32 permissionId;\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"./IERC165.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of the {IERC165} interface.\\\\n *\\\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\\\n * for the additional interface id that will be supported. For example:\\\\n *\\\\n * ```solidity\\\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\\\n * }\\\\n * ```\\\\n *\\\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\\\n */\\\\nabstract contract ERC165 is IERC165 {\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n        return interfaceId == type(IERC165).interfaceId;\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"./IERC165.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev Library used to query support of an interface declared via {IERC165}.\\\\n *\\\\n * Note that these functions return the actual result of the query: they do not\\\\n * `revert` if an interface is not supported. It is up to the caller to decide\\\\n * what to do in these cases.\\\\n */\\\\nlibrary ERC165Checker {\\\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\\\n\\\\n    /**\\\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\\\n     */\\\\n    function supportsERC165(address account) internal view returns (bool) {\\\\n        // Any contract that implements ERC165 must explicitly indicate support of\\\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\\\n        return\\\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns true if `account` supports the interface defined by\\\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\\\n     *\\\\n     * See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns a boolean array where each value corresponds to the\\\\n     * interfaces passed in and whether they're supported or not. This allows\\\\n     * you to batch check interfaces for a contract where your expectation\\\\n     * is that some interfaces may not be supported.\\\\n     *\\\\n     * See {IERC165-supportsInterface}.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function getSupportedInterfaces(\\\\n        address account,\\\\n        bytes4[] memory interfaceIds\\\\n    ) internal view returns (bool[] memory) {\\\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\\\n\\\\n        // query support of ERC165 itself\\\\n        if (supportsERC165(account)) {\\\\n            // query support of each interface in interfaceIds\\\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\\\n            }\\\\n        }\\\\n\\\\n        return interfaceIdsSupported;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns true if `account` supports all the interfaces defined in\\\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\\\n     *\\\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\\\n     * {IERC165} support.\\\\n     *\\\\n     * See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\\\n        // query support of ERC165 itself\\\\n        if (!supportsERC165(account)) {\\\\n            return false;\\\\n        }\\\\n\\\\n        // query support of each interface in interfaceIds\\\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\\\n                return false;\\\\n            }\\\\n        }\\\\n\\\\n        // all interfaces supported\\\\n        return true;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\\\n     * @param account The address of the contract to query for support of an interface\\\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\\\n     * @return true if the contract at account indicates support of the interface with\\\\n     * identifier interfaceId, false otherwise\\\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\\\n     * the behavior of this method is undefined. This precondition can be checked\\\\n     * with {supportsERC165}.\\\\n     *\\\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\\\n     * should be exercised when using this function.\\\\n     *\\\\n     * Interface identification is specified in ERC-165.\\\\n     */\\\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\\\n        // prepare call\\\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\\\n\\\\n        // perform static call\\\\n        bool success;\\\\n        uint256 returnSize;\\\\n        uint256 returnValue;\\\\n        assembly {\\\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\\\n            returnSize := returndatasize()\\\\n            returnValue := mload(0x00)\\\\n        }\\\\n\\\\n        return success && returnSize >= 0x20 && returnValue > 0;\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\\\n * deploying minimal proxy contracts, also known as \\\\\\\"clones\\\\\\\".\\\\n *\\\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\\\n *\\\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\\\n * deterministic method.\\\\n *\\\\n * _Available since v3.4._\\\\n */\\\\nlibrary Clones {\\\\n    /**\\\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\\\n     *\\\\n     * This function uses the create opcode, which should never revert.\\\\n     */\\\\n    function clone(address implementation) internal returns (address instance) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\\\n            // of the `implementation` address with the bytecode before the address.\\\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\\\n            instance := create(0, 0x09, 0x37)\\\\n        }\\\\n        require(instance != address(0), \\\\\\\"ERC1167: create failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\\\n     *\\\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\\\n     * the clones cannot be deployed twice at the same address.\\\\n     */\\\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\\\n            // of the `implementation` address with the bytecode before the address.\\\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\\\n            instance := create2(0, 0x09, 0x37, salt)\\\\n        }\\\\n        require(instance != address(0), \\\\\\\"ERC1167: create2 failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\\\n     */\\\\n    function predictDeterministicAddress(\\\\n        address implementation,\\\\n        bytes32 salt,\\\\n        address deployer\\\\n    ) internal pure returns (address predicted) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            let ptr := mload(0x40)\\\\n            mstore(add(ptr, 0x38), deployer)\\\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\\\n            mstore(add(ptr, 0x14), implementation)\\\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\\\n            mstore(add(ptr, 0x58), salt)\\\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\\\n     */\\\\n    function predictDeterministicAddress(\\\\n        address implementation,\\\\n        bytes32 salt\\\\n    ) internal view returns (address predicted) {\\\\n        return predictDeterministicAddress(implementation, salt, address(this));\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/utils/Proxy.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\nimport \\\\\\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\\\\\";\\\\n\\\\n/// @notice Free function to create a [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy contract based on the passed base contract address.\\\\n/// @param _logic The base contract address.\\\\n/// @param _data The constructor arguments for this contract.\\\\n/// @return The address of the proxy contract created.\\\\n/// @dev Initializes the upgradeable proxy with an initial implementation specified by _logic. If _data is non-empty, it’s used as data in a delegate call to _logic. This will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity constructor (see [OpenZeppelin ERC1967Proxy-constructor](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy-constructor-address-bytes-)).\\\\nfunction createERC1967Proxy(address _logic, bytes memory _data) returns (address) {\\\\n    return address(new ERC1967Proxy(_logic, _data));\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/plugin/PluginUUPSUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\nimport {UUPSUpgradeable} from \\\\\\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\\\\\";\\\\nimport {IERC1822ProxiableUpgradeable} from \\\\\\\"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\\\\\\\";\\\\nimport {ERC165Upgradeable} from \\\\\\\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\\\\\\\";\\\\n\\\\nimport {IDAO} from \\\\\\\"../dao/IDAO.sol\\\\\\\";\\\\nimport {DaoAuthorizableUpgradeable} from \\\\\\\"./dao-authorizable/DaoAuthorizableUpgradeable.sol\\\\\\\";\\\\nimport {IPlugin} from \\\\\\\"./IPlugin.sol\\\\\\\";\\\\n\\\\n/// @title PluginUUPSUpgradeable\\\\n/// @author Aragon Association - 2022-2023\\\\n/// @notice An abstract, upgradeable contract to inherit from when creating a plugin being deployed via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\\\\nabstract contract PluginUUPSUpgradeable is\\\\n    IPlugin,\\\\n    ERC165Upgradeable,\\\\n    UUPSUpgradeable,\\\\n    DaoAuthorizableUpgradeable\\\\n{\\\\n    // NOTE: When adding new state variables to the contract, the size of `_gap` has to be adapted below as well.\\\\n\\\\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\\\\n    constructor() {\\\\n        _disableInitializers();\\\\n    }\\\\n\\\\n    /// @inheritdoc IPlugin\\\\n    function pluginType() public pure override returns (PluginType) {\\\\n        return PluginType.UUPS;\\\\n    }\\\\n\\\\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\\\\n    bytes32 public constant UPGRADE_PLUGIN_PERMISSION_ID = keccak256(\\\\\\\"UPGRADE_PLUGIN_PERMISSION\\\\\\\");\\\\n\\\\n    /// @notice Initializes the plugin by storing the associated DAO.\\\\n    /// @param _dao The DAO contract.\\\\n    function __PluginUUPSUpgradeable_init(IDAO _dao) internal virtual onlyInitializing {\\\\n        __DaoAuthorizableUpgradeable_init(_dao);\\\\n    }\\\\n\\\\n    /// @notice Checks if an interface is supported by this or its parent contract.\\\\n    /// @param _interfaceId The ID of the interface.\\\\n    /// @return Returns `true` if the interface is supported.\\\\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\\\n        return\\\\n            _interfaceId == type(IPlugin).interfaceId ||\\\\n            _interfaceId == type(IERC1822ProxiableUpgradeable).interfaceId ||\\\\n            super.supportsInterface(_interfaceId);\\\\n    }\\\\n\\\\n    /// @notice Returns the address of the implementation contract in the [proxy storage slot](https://eips.ethereum.org/EIPS/eip-1967) slot the [UUPS proxy](https://eips.ethereum.org/EIPS/eip-1822) is pointing to.\\\\n    /// @return The address of the implementation contract.\\\\n    function implementation() public view returns (address) {\\\\n        return _getImplementation();\\\\n    }\\\\n\\\\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\\\\n    /// @dev The caller must have the `UPGRADE_PLUGIN_PERMISSION_ID` permission.\\\\n    function _authorizeUpgrade(\\\\n        address\\\\n    ) internal virtual override auth(UPGRADE_PLUGIN_PERMISSION_ID) {}\\\\n\\\\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\\\\n    uint256[50] private __gap;\\\\n}\\\\n\\\"},\\\"src/interfaces/IPayments.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: UNLICENSED\\\\npragma solidity ^0.8.17;\\\\n\\\\n/**\\\\n * @title Payments Interface\\\\n * @dev Interface for interacting with the Payments contract, which handles payments and subscription management.\\\\n */\\\\ninterface IPayments {\\\\n    // Events\\\\n    event PaymentScheduleActive(\\\\n        string indexed username,\\\\n        address token,\\\\n        uint40 nextPayout,\\\\n        uint256 amount\\\\n    );\\\\n    event StreamActive(\\\\n        string indexed username,\\\\n        address token,\\\\n        uint40 startDate,\\\\n        uint40 endDate,\\\\n        uint256 amount\\\\n    );\\\\n    event PaymentExecuted(\\\\n        string indexed username,\\\\n        address token,\\\\n        uint256 amount\\\\n    );\\\\n    event StreamPaymentExecuted(\\\\n        string indexed username,\\\\n        address token,\\\\n        uint256 amount\\\\n    );\\\\n    event UserAddressUpdated(string indexed username, address newAddress);\\\\n\\\\n    /**\\\\n     * @dev Represents a scheduled payment, including both recurring and one-time payments.\\\\n        A mapping of username to this struct defines the payment\\\\n     * @param token The token address used for the payment.\\\\n     * @param nextPayout The timestamp when the next payment is due.\\\\n     * @param isOneTime Indicates whether the payment is a one-time occurrence.\\\\n     * @param active Indicates whether the payment is active \\\\n     * @param amount The amount to be paid per interval (e.g., monthly).\\\\n     */\\\\n    struct Schedule {\\\\n        address token;\\\\n        uint40 nextPayout;\\\\n        bool isOneTime;\\\\n        bool active;\\\\n        uint256 amount;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Represents a stream payment.\\\\n        A mapping of username to this struct defines the payment stream\\\\n     * @param token The token address used for the payment.\\\\n     * @param startDate The timestamp when the stream starts.\\\\n     * @param endDate The timestamp when the stream ends.\\\\n     * @param active Indicates whether the stream is active.\\\\n     * @param amount The amount to be streamed per second.\\\\n     * @param lastPayout The timestamp of the last payout.\\\\n     */\\\\n    struct Stream {\\\\n        address token;\\\\n        uint40 startDate;\\\\n        uint40 endDate;\\\\n        bool active;\\\\n        uint256 amount;\\\\n        uint40 lastPayout;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Allows a user to claim a username.\\\\n     * @dev This function allows a user to claim a username.\\\\n     * @param username The username to claim.\\\\n     */\\\\n    function claimUsername(string calldata username) external;\\\\n\\\\n    /**\\\\n     * @notice Updates the wallet address for a given username.\\\\n     * @dev This function allows an authorized address to update the mapping of username to wallet address.\\\\n     *      Only specific addresses (e.g., admin or authorized addresses) can call this function.\\\\n     * @param username The username whose wallet address needs to be updated.\\\\n     * @param userAddress The new wallet address to associate with the username.\\\\n     */\\\\n    function updateUserAddress(\\\\n        string calldata username,\\\\n        address userAddress\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @notice Retrieves the wallet address associated with a given username.\\\\n     * @dev This function allows anyone to check the wallet address associated with a specific username.\\\\n     * @param username The username whose wallet address is to be retrieved.\\\\n     * @return The wallet address associated with the username.\\\\n     */\\\\n    function getUserAddress(\\\\n        string calldata username\\\\n    ) external view returns (address);\\\\n\\\\n    /**\\\\n     * @notice Creates a scheduled payment for a username\\\\n     * @param username The username to create the schedule for\\\\n     * @param amount The amount to be paid\\\\n     * @param token The token address to be used for payment\\\\n     * @param oneTimePayoutDate If non-zero, creates a one-time payment at this date\\\\n     */\\\\n    function createSchedule(\\\\n        string calldata username,\\\\n        uint256 amount,\\\\n        address token,\\\\n        uint40 oneTimePayoutDate\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @notice Creates a stream payment for a username\\\\n     * @param username The username to create the stream for\\\\n     * @param amount The amount to be streamed\\\\n     * @param token The token address to be used for payment\\\\n     * @param endStream The timestamp when the stream should end\\\\n     */\\\\n    function createStream(\\\\n        string calldata username,\\\\n        uint256 amount,\\\\n        address token,\\\\n        uint40 endStream\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @notice Executes a scheduled payment if due\\\\n     * @param username The username whose payment to execute\\\\n     */\\\\n    function executePayment(string calldata username) external;\\\\n\\\\n    /**\\\\n     * @notice Executes a stream payment\\\\n     * @param username The username whose stream to execute\\\\n     */\\\\n    function executeStream(string calldata username) external;\\\\n\\\\n    /**\\\\n     * @notice Retrieves the current stream details for a user.\\\\n     * @param username The username to query stream against.\\\\n     * @return stream The stream information.\\\\n     */\\\\n    function getStream(\\\\n        string calldata username\\\\n    ) external view returns (Stream memory stream);\\\\n\\\\n    /**\\\\n     * @notice Retrieves the current schedule payment details for a user.\\\\n     * @param username The username to query schedule against.\\\\n     * @return schedule The schedule information.\\\\n     */\\\\n    function getSchedule(\\\\n        string calldata username\\\\n    ) external view returns (Schedule memory schedule);\\\\n}\\\\n\\\"},\\\"src/util/Errors.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: UNLICENSED\\\\npragma solidity ^0.8.13;\\\\n\\\\n/**\\\\n * @title Errors\\\\n * @dev Custom error definitions for the Paynest system.\\\\n */\\\\nabstract contract Errors {\\\\n    // Authorization errors\\\\n    error NotAuthorized();\\\\n\\\\n    // Token errors\\\\n    error TokenNotSupported();\\\\n    error TokenAlreadySupported();\\\\n    error InsufficientBalance();\\\\n\\\\n    // Subscription errors\\\\n    error InsufficientFee();\\\\n    error MaxOrganizationsReached();\\\\n\\\\n    // Directory errors\\\\n    error UserNotFound(string username);\\\\n    error IncompatibleUserAddress();\\\\n    error UsernameAlreadyClaimed(string username);\\\\n    error EmptyUsernameNotAllowed();\\\\n\\\\n    // Payment Errors\\\\n    error ActivePayment(string username);\\\\n    error InActivePayment(string username);\\\\n    error NoActivePayment(string username);\\\\n    error InvalidAmount();\\\\n    error InvalidEndDate();\\\\n    error InvalidStreamEnd();\\\\n    error NoPayoutDue();\\\\n    error NoEditAccess();\\\\n    error InvalidSubscriptionPeriod();\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"../IERC20.sol\\\\\\\";\\\\nimport \\\\\\\"../extensions/IERC20Permit.sol\\\\\\\";\\\\nimport \\\\\\\"../../../utils/Address.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @title SafeERC20\\\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\\\n * contract returns false). Tokens that return no value (and instead revert or\\\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\\\n * successful.\\\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\\\n */\\\\nlibrary SafeERC20 {\\\\n    using Address for address;\\\\n\\\\n    /**\\\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\\\n     * non-reverting calls are assumed to be successful.\\\\n     */\\\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\\\n     */\\\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Deprecated. This function has issues similar to the ones found in\\\\n     * {IERC20-approve}, and its usage is discouraged.\\\\n     *\\\\n     * Whenever possible, use {safeIncreaseAllowance} and\\\\n     * {safeDecreaseAllowance} instead.\\\\n     */\\\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\\\n        // safeApprove should only be called when setting an initial allowance,\\\\n        // or when resetting it to zero. To increase and decrease it, use\\\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\\\n        require(\\\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\\\n            \\\\\\\"SafeERC20: approve from non-zero to non-zero allowance\\\\\\\"\\\\n        );\\\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\\\n     * non-reverting calls are assumed to be successful.\\\\n     */\\\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\\\n     * non-reverting calls are assumed to be successful.\\\\n     */\\\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\\\n        unchecked {\\\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\\\n            require(oldAllowance >= value, \\\\\\\"SafeERC20: decreased allowance below zero\\\\\\\");\\\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\\\n     * 0 before setting it to a non-zero value.\\\\n     */\\\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\\\n\\\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\\\n            _callOptionalReturn(token, approvalCall);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\\\n     * Revert on invalid signature.\\\\n     */\\\\n    function safePermit(\\\\n        IERC20Permit token,\\\\n        address owner,\\\\n        address spender,\\\\n        uint256 value,\\\\n        uint256 deadline,\\\\n        uint8 v,\\\\n        bytes32 r,\\\\n        bytes32 s\\\\n    ) internal {\\\\n        uint256 nonceBefore = token.nonces(owner);\\\\n        token.permit(owner, spender, value, deadline, v, r, s);\\\\n        uint256 nonceAfter = token.nonces(owner);\\\\n        require(nonceAfter == nonceBefore + 1, \\\\\\\"SafeERC20: permit did not succeed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\\\n     * @param token The token targeted by the call.\\\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\\\n     */\\\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\\\n        // the target address contains contract code and also asserts for success in the low-level call.\\\\n\\\\n        bytes memory returndata = address(token).functionCall(data, \\\\\\\"SafeERC20: low-level call failed\\\\\\\");\\\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\\\\\"SafeERC20: ERC20 operation did not succeed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\\\n     * @param token The token targeted by the call.\\\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\\\n     *\\\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\\\n     */\\\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\\\n        // and not revert is the subcall reverts.\\\\n\\\\n        (bool success, bytes memory returndata) = address(token).call(data);\\\\n        return\\\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\\\n */\\\\ninterface IERC20 {\\\\n    /**\\\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\\\n     * another (`to`).\\\\n     *\\\\n     * Note that `value` may be zero.\\\\n     */\\\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\\\n     * a call to {approve}. `value` is the new allowance.\\\\n     */\\\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens in existence.\\\\n     */\\\\n    function totalSupply() external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens owned by `account`.\\\\n     */\\\\n    function balanceOf(address account) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transfer(address to, uint256 amount) external returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Returns the remaining number of tokens that `spender` will be\\\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\\\n     * zero by default.\\\\n     *\\\\n     * This value changes when {approve} or {transferFrom} are called.\\\\n     */\\\\n    function allowance(address owner, address spender) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\\\n     * that someone may use both the old and the new allowance by unfortunate\\\\n     * transaction ordering. One possible solution to mitigate this race\\\\n     * condition is to first reduce the spender's allowance to 0 and set the\\\\n     * desired value afterwards:\\\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function approve(address spender, uint256 amount) external returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\\\n     * allowance mechanism. `amount` is then deducted from the caller's\\\\n     * allowance.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165StorageUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"./ERC165Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../../proxy/utils/Initializable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev Storage based implementation of the {IERC165} interface.\\\\n *\\\\n * Contracts may inherit from this and call {_registerInterface} to declare\\\\n * their support of an interface.\\\\n */\\\\nabstract contract ERC165StorageUpgradeable is Initializable, ERC165Upgradeable {\\\\n    function __ERC165Storage_init() internal onlyInitializing {\\\\n    }\\\\n\\\\n    function __ERC165Storage_init_unchained() internal onlyInitializing {\\\\n    }\\\\n    /**\\\\n     * @dev Mapping of interface ids to whether or not it's supported.\\\\n     */\\\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\\\n\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Registers the contract as an implementer of the interface defined by\\\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\\\n     * registering its interface id is not required.\\\\n     *\\\\n     * See {IERC165-supportsInterface}.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\\\n     */\\\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\\\n        require(interfaceId != 0xffffffff, \\\\\\\"ERC165: invalid interface id\\\\\\\");\\\\n        _supportedInterfaces[interfaceId] = true;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\\\n     * variables without shifting down storage in the inheritance chain.\\\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\\\n     */\\\\n    uint256[49] private __gap;\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\\\n\\\\npragma solidity ^0.8.2;\\\\n\\\\nimport \\\\\\\"../../utils/AddressUpgradeable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\\\n *\\\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\\\n * reused. This mechanism prevents re-execution of each \\\\\\\"step\\\\\\\" but allows the creation of new initialization steps in\\\\n * case an upgrade adds a module that needs to be initialized.\\\\n *\\\\n * For example:\\\\n *\\\\n * [.hljs-theme-light.nopadding]\\\\n * ```solidity\\\\n * contract MyToken is ERC20Upgradeable {\\\\n *     function initialize() initializer public {\\\\n *         __ERC20_init(\\\\\\\"MyToken\\\\\\\", \\\\\\\"MTK\\\\\\\");\\\\n *     }\\\\n * }\\\\n *\\\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\\\n *     function initializeV2() reinitializer(2) public {\\\\n *         __ERC20Permit_init(\\\\\\\"MyToken\\\\\\\");\\\\n *     }\\\\n * }\\\\n * ```\\\\n *\\\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\\\n *\\\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\\\n *\\\\n * [CAUTION]\\\\n * ====\\\\n * Avoid leaving a contract uninitialized.\\\\n *\\\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\\\n *\\\\n * [.hljs-theme-light.nopadding]\\\\n * ```\\\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\\\n * constructor() {\\\\n *     _disableInitializers();\\\\n * }\\\\n * ```\\\\n * ====\\\\n */\\\\nabstract contract Initializable {\\\\n    /**\\\\n     * @dev Indicates that the contract has been initialized.\\\\n     * @custom:oz-retyped-from bool\\\\n     */\\\\n    uint8 private _initialized;\\\\n\\\\n    /**\\\\n     * @dev Indicates that the contract is in the process of being initialized.\\\\n     */\\\\n    bool private _initializing;\\\\n\\\\n    /**\\\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\\\n     */\\\\n    event Initialized(uint8 version);\\\\n\\\\n    /**\\\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\\\n     *\\\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\\\n     * constructor.\\\\n     *\\\\n     * Emits an {Initialized} event.\\\\n     */\\\\n    modifier initializer() {\\\\n        bool isTopLevelCall = !_initializing;\\\\n        require(\\\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\\\n            \\\\\\\"Initializable: contract is already initialized\\\\\\\"\\\\n        );\\\\n        _initialized = 1;\\\\n        if (isTopLevelCall) {\\\\n            _initializing = true;\\\\n        }\\\\n        _;\\\\n        if (isTopLevelCall) {\\\\n            _initializing = false;\\\\n            emit Initialized(1);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\\\n     * used to initialize parent contracts.\\\\n     *\\\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\\\n     * are added through upgrades and that require initialization.\\\\n     *\\\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\\\n     *\\\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\\\n     * a contract, executing them in the right order is up to the developer or operator.\\\\n     *\\\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\\\n     *\\\\n     * Emits an {Initialized} event.\\\\n     */\\\\n    modifier reinitializer(uint8 version) {\\\\n        require(!_initializing && _initialized < version, \\\\\\\"Initializable: contract is already initialized\\\\\\\");\\\\n        _initialized = version;\\\\n        _initializing = true;\\\\n        _;\\\\n        _initializing = false;\\\\n        emit Initialized(version);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\\\n     */\\\\n    modifier onlyInitializing() {\\\\n        require(_initializing, \\\\\\\"Initializable: contract is not initializing\\\\\\\");\\\\n        _;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\\\n     * through proxies.\\\\n     *\\\\n     * Emits an {Initialized} event the first time it is successfully executed.\\\\n     */\\\\n    function _disableInitializers() internal virtual {\\\\n        require(!_initializing, \\\\\\\"Initializable: contract is initializing\\\\\\\");\\\\n        if (_initialized != type(uint8).max) {\\\\n            _initialized = type(uint8).max;\\\\n            emit Initialized(type(uint8).max);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\\\n     */\\\\n    function _getInitializedVersion() internal view returns (uint8) {\\\\n        return _initialized;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\\\n     */\\\\n    function _isInitializing() internal view returns (bool) {\\\\n        return _initializing;\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"./Initializable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\\\n *\\\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\\\n *\\\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\\\n *\\\\n * _Available since v4.1._\\\\n */\\\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\\\n    }\\\\n\\\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\\\n    }\\\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\\\n    address private immutable __self = address(this);\\\\n\\\\n    /**\\\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\\\n     * fail.\\\\n     */\\\\n    modifier onlyProxy() {\\\\n        require(address(this) != __self, \\\\\\\"Function must be called through delegatecall\\\\\\\");\\\\n        require(_getImplementation() == __self, \\\\\\\"Function must be called through active proxy\\\\\\\");\\\\n        _;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\\\n     * callable on the implementing contract but not through proxies.\\\\n     */\\\\n    modifier notDelegated() {\\\\n        require(address(this) == __self, \\\\\\\"UUPSUpgradeable: must not be called through delegatecall\\\\\\\");\\\\n        _;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\\\n     *\\\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\\\n     */\\\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\\\n        return _IMPLEMENTATION_SLOT;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\\\n     *\\\\n     * Calls {_authorizeUpgrade}.\\\\n     *\\\\n     * Emits an {Upgraded} event.\\\\n     *\\\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\\\n     */\\\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\\\n        _authorizeUpgrade(newImplementation);\\\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\\\n     * encoded in `data`.\\\\n     *\\\\n     * Calls {_authorizeUpgrade}.\\\\n     *\\\\n     * Emits an {Upgraded} event.\\\\n     *\\\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\\\n     */\\\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\\\n        _authorizeUpgrade(newImplementation);\\\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\\\n     * {upgradeTo} and {upgradeToAndCall}.\\\\n     *\\\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\\\n     *\\\\n     * ```solidity\\\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\\\n     * ```\\\\n     */\\\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\\\n\\\\n    /**\\\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\\\n     * variables without shifting down storage in the inheritance chain.\\\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\\\n     */\\\\n    uint256[50] private __gap;\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"../IERC20Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../extensions/IERC20PermitUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../../../utils/AddressUpgradeable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @title SafeERC20\\\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\\\n * contract returns false). Tokens that return no value (and instead revert or\\\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\\\n * successful.\\\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\\\n */\\\\nlibrary SafeERC20Upgradeable {\\\\n    using AddressUpgradeable for address;\\\\n\\\\n    /**\\\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\\\n     * non-reverting calls are assumed to be successful.\\\\n     */\\\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\\\n     */\\\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Deprecated. This function has issues similar to the ones found in\\\\n     * {IERC20-approve}, and its usage is discouraged.\\\\n     *\\\\n     * Whenever possible, use {safeIncreaseAllowance} and\\\\n     * {safeDecreaseAllowance} instead.\\\\n     */\\\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\\\n        // safeApprove should only be called when setting an initial allowance,\\\\n        // or when resetting it to zero. To increase and decrease it, use\\\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\\\n        require(\\\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\\\n            \\\\\\\"SafeERC20: approve from non-zero to non-zero allowance\\\\\\\"\\\\n        );\\\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\\\n     * non-reverting calls are assumed to be successful.\\\\n     */\\\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\\\n     * non-reverting calls are assumed to be successful.\\\\n     */\\\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\\\n        unchecked {\\\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\\\n            require(oldAllowance >= value, \\\\\\\"SafeERC20: decreased allowance below zero\\\\\\\");\\\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\\\n     * 0 before setting it to a non-zero value.\\\\n     */\\\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\\\n\\\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\\\n            _callOptionalReturn(token, approvalCall);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\\\n     * Revert on invalid signature.\\\\n     */\\\\n    function safePermit(\\\\n        IERC20PermitUpgradeable token,\\\\n        address owner,\\\\n        address spender,\\\\n        uint256 value,\\\\n        uint256 deadline,\\\\n        uint8 v,\\\\n        bytes32 r,\\\\n        bytes32 s\\\\n    ) internal {\\\\n        uint256 nonceBefore = token.nonces(owner);\\\\n        token.permit(owner, spender, value, deadline, v, r, s);\\\\n        uint256 nonceAfter = token.nonces(owner);\\\\n        require(nonceAfter == nonceBefore + 1, \\\\\\\"SafeERC20: permit did not succeed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\\\n     * @param token The token targeted by the call.\\\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\\\n     */\\\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\\\n        // the target address contains contract code and also asserts for success in the low-level call.\\\\n\\\\n        bytes memory returndata = address(token).functionCall(data, \\\\\\\"SafeERC20: low-level call failed\\\\\\\");\\\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\\\\\"SafeERC20: ERC20 operation did not succeed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\\\n     * @param token The token targeted by the call.\\\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\\\n     *\\\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\\\n     */\\\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\\\n        // and not revert is the subcall reverts.\\\\n\\\\n        (bool success, bytes memory returndata) = address(token).call(data);\\\\n        return\\\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\\\n */\\\\ninterface IERC20Upgradeable {\\\\n    /**\\\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\\\n     * another (`to`).\\\\n     *\\\\n     * Note that `value` may be zero.\\\\n     */\\\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\\\n     * a call to {approve}. `value` is the new allowance.\\\\n     */\\\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens in existence.\\\\n     */\\\\n    function totalSupply() external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens owned by `account`.\\\\n     */\\\\n    function balanceOf(address account) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transfer(address to, uint256 amount) external returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Returns the remaining number of tokens that `spender` will be\\\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\\\n     * zero by default.\\\\n     *\\\\n     * This value changes when {approve} or {transferFrom} are called.\\\\n     */\\\\n    function allowance(address owner, address spender) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\\\n     * that someone may use both the old and the new allowance by unfortunate\\\\n     * transaction ordering. One possible solution to mitigate this race\\\\n     * condition is to first reduce the spender's allowance to 0 and set the\\\\n     * desired value afterwards:\\\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function approve(address spender, uint256 amount) external returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\\\n     * allowance mechanism. `amount` is then deducted from the caller's\\\\n     * allowance.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC721/IERC721ReceiverUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @title ERC721 token receiver interface\\\\n * @dev Interface for any contract that wants to support safeTransfers\\\\n * from ERC721 asset contracts.\\\\n */\\\\ninterface IERC721ReceiverUpgradeable {\\\\n    /**\\\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\\\n     * by `operator` from `from`, this function is called.\\\\n     *\\\\n     * It must return its Solidity selector to confirm the token transfer.\\\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\\\n     *\\\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\\\n     */\\\\n    function onERC721Received(\\\\n        address operator,\\\\n        address from,\\\\n        uint256 tokenId,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/IERC1155Upgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"../../utils/introspection/IERC165Upgradeable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\\\n *\\\\n * _Available since v3.1._\\\\n */\\\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\\\n    /**\\\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\\\n     */\\\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\\\n     * transfers.\\\\n     */\\\\n    event TransferBatch(\\\\n        address indexed operator,\\\\n        address indexed from,\\\\n        address indexed to,\\\\n        uint256[] ids,\\\\n        uint256[] values\\\\n    );\\\\n\\\\n    /**\\\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\\\n     * `approved`.\\\\n     */\\\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\\\n     *\\\\n     * If an {URI} event was emitted for `id`, the standard\\\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\\\n     * returned by {IERC1155MetadataURI-uri}.\\\\n     */\\\\n    event URI(string value, uint256 indexed id);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `account` cannot be the zero address.\\\\n     */\\\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `accounts` and `ids` must have the same length.\\\\n     */\\\\n    function balanceOfBatch(\\\\n        address[] calldata accounts,\\\\n        uint256[] calldata ids\\\\n    ) external view returns (uint256[] memory);\\\\n\\\\n    /**\\\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `operator` cannot be the caller.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    /**\\\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\\\n     *\\\\n     * See {setApprovalForAll}.\\\\n     */\\\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\\\n     *\\\\n     * Emits a {TransferSingle} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `to` cannot be the zero address.\\\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\\\n     * acceptance magic value.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\\\n\\\\n    /**\\\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\\\n     *\\\\n     * Emits a {TransferBatch} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `ids` and `amounts` must have the same length.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\\\n     * acceptance magic value.\\\\n     */\\\\n    function safeBatchTransferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256[] calldata ids,\\\\n        uint256[] calldata amounts,\\\\n        bytes calldata data\\\\n    ) external;\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"../../utils/introspection/IERC165Upgradeable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev _Available since v3.1._\\\\n */\\\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\\\n    /**\\\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\\\n     *\\\\n     * NOTE: To accept the transfer, this must return\\\\n     * `bytes4(keccak256(\\\\\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\\\\\"))`\\\\n     * (i.e. 0xf23a6e61, or its own function selector).\\\\n     *\\\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\\\n     * @param from The address which previously owned the token\\\\n     * @param id The ID of the token being transferred\\\\n     * @param value The amount of tokens being transferred\\\\n     * @param data Additional data with no specified format\\\\n     * @return `bytes4(keccak256(\\\\\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\\\\\"))` if transfer is allowed\\\\n     */\\\\n    function onERC1155Received(\\\\n        address operator,\\\\n        address from,\\\\n        uint256 id,\\\\n        uint256 value,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n\\\\n    /**\\\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\\\n     * been updated.\\\\n     *\\\\n     * NOTE: To accept the transfer(s), this must return\\\\n     * `bytes4(keccak256(\\\\\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\\\\\"))`\\\\n     * (i.e. 0xbc197c81, or its own function selector).\\\\n     *\\\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\\\n     * @param from The address which previously owned the token\\\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\\\n     * @param data Additional data with no specified format\\\\n     * @return `bytes4(keccak256(\\\\\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\\\\\"))` if transfer is allowed\\\\n     */\\\\n    function onERC1155BatchReceived(\\\\n        address operator,\\\\n        address from,\\\\n        uint256[] calldata ids,\\\\n        uint256[] calldata values,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\\\n\\\\npragma solidity ^0.8.1;\\\\n\\\\n/**\\\\n * @dev Collection of functions related to the address type\\\\n */\\\\nlibrary AddressUpgradeable {\\\\n    /**\\\\n     * @dev Returns true if `account` is a contract.\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * It is unsafe to assume that an address for which this function returns\\\\n     * false is an externally-owned account (EOA) and not a contract.\\\\n     *\\\\n     * Among others, `isContract` will return false for the following\\\\n     * types of addresses:\\\\n     *\\\\n     *  - an externally-owned account\\\\n     *  - a contract in construction\\\\n     *  - an address where a contract will be created\\\\n     *  - an address where a contract lived, but was destroyed\\\\n     *\\\\n     * Furthermore, `isContract` will also return true if the target contract within\\\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\\\n     * which only has an effect at the end of a transaction.\\\\n     * ====\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\\\n     *\\\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\\\n     * constructor.\\\\n     * ====\\\\n     */\\\\n    function isContract(address account) internal view returns (bool) {\\\\n        // This method relies on extcodesize/address.code.length, which returns 0\\\\n        // for contracts in construction, since the code is only stored at the end\\\\n        // of the constructor execution.\\\\n\\\\n        return account.code.length > 0;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\\\n     * `recipient`, forwarding all available gas and reverting on errors.\\\\n     *\\\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\\\n     * imposed by `transfer`, making them unable to receive funds via\\\\n     * `transfer`. {sendValue} removes this limitation.\\\\n     *\\\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\\\n     *\\\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\\\n     * taken to not create reentrancy vulnerabilities. Consider using\\\\n     * {ReentrancyGuard} or the\\\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\\\n     */\\\\n    function sendValue(address payable recipient, uint256 amount) internal {\\\\n        require(address(this).balance >= amount, \\\\\\\"Address: insufficient balance\\\\\\\");\\\\n\\\\n        (bool success, ) = recipient.call{value: amount}(\\\\\\\"\\\\\\\");\\\\n        require(success, \\\\\\\"Address: unable to send value, recipient may have reverted\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Performs a Solidity function call using a low level `call`. A\\\\n     * plain `call` is an unsafe replacement for a function call: use this\\\\n     * function instead.\\\\n     *\\\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\\\n     * function (like regular Solidity function calls).\\\\n     *\\\\n     * Returns the raw returned data. To convert to the expected return value,\\\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `target` must be a contract.\\\\n     * - calling `target` with `data` must not revert.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, \\\\\\\"Address: low-level call failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but also transferring `value` wei to `target`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - the calling contract must have an ETH balance of at least `value`.\\\\n     * - the called Solidity function must be `payable`.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, value, \\\\\\\"Address: low-level call with value failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(\\\\n        address target,\\\\n        bytes memory data,\\\\n        uint256 value,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        require(address(this).balance >= value, \\\\\\\"Address: insufficient balance for call\\\\\\\");\\\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\\\n        return functionStaticCall(target, data, \\\\\\\"Address: low-level static call failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionDelegateCall(target, data, \\\\\\\"Address: low-level delegate call failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\\\n     *\\\\n     * _Available since v4.8._\\\\n     */\\\\n    function verifyCallResultFromTarget(\\\\n        address target,\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        if (success) {\\\\n            if (returndata.length == 0) {\\\\n                // only check isContract if the call was successful and the return data is empty\\\\n                // otherwise we already know that it was a contract\\\\n                require(isContract(target), \\\\\\\"Address: call to non-contract\\\\\\\");\\\\n            }\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\\\n     * revert reason or using the provided one.\\\\n     *\\\\n     * _Available since v4.3._\\\\n     */\\\\n    function verifyCallResult(\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal pure returns (bytes memory) {\\\\n        if (success) {\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\\\n        // Look for revert reason and bubble it up if present\\\\n        if (returndata.length > 0) {\\\\n            // The easiest way to bubble the revert reason is using memory via assembly\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                let returndata_size := mload(returndata)\\\\n                revert(add(32, returndata), returndata_size)\\\\n            }\\\\n        } else {\\\\n            revert(errorMessage);\\\\n        }\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC1271 standard signature validation method for\\\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\\\n *\\\\n * _Available since v4.1._\\\\n */\\\\ninterface IERC1271 {\\\\n    /**\\\\n     * @dev Should return whether the signature provided is valid for the provided data\\\\n     * @param hash      Hash of the data to be signed\\\\n     * @param signature Signature byte array associated with _data\\\\n     */\\\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/utils/protocol/IProtocolVersion.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\n/// @title IProtocolVersion\\\\n/// @author Aragon Association - 2022-2023\\\\n/// @notice An interface defining the semantic OSx protocol version.\\\\ninterface IProtocolVersion {\\\\n    /// @notice Returns the protocol version at which the current contract was built. Use it to check for future upgrades that might be applicable.\\\\n    /// @return _version Returns the semantic OSx protocol version.\\\\n    function protocolVersion() external view returns (uint8[3] memory _version);\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/utils/protocol/ProtocolVersion.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity 0.8.17;\\\\n\\\\nimport {IProtocolVersion} from \\\\\\\"./IProtocolVersion.sol\\\\\\\";\\\\n\\\\n/// @title ProtocolVersion\\\\n/// @author Aragon Association - 2023\\\\n/// @notice An abstract, stateless, non-upgradeable contract serves as a base for other contracts requiring awareness of the OSx protocol version.\\\\n/// @dev Do not add any new variables to this contract that would shift down storage in the inheritance chain.\\\\nabstract contract ProtocolVersion is IProtocolVersion {\\\\n    // IMPORTANT: Do not add any storage variable, see the above notice.\\\\n\\\\n    /// @inheritdoc IProtocolVersion\\\\n    function protocolVersion() public pure returns (uint8[3] memory) {\\\\n        return [1, 3, 0];\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/permission/PermissionManager.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\\\\\";\\\\nimport \\\\\\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\\\\\";\\\\n\\\\nimport {IPermissionCondition} from \\\\\\\"./IPermissionCondition.sol\\\\\\\";\\\\nimport {PermissionCondition} from \\\\\\\"./PermissionCondition.sol\\\\\\\";\\\\nimport \\\\\\\"./PermissionLib.sol\\\\\\\";\\\\n\\\\n/// @title PermissionManager\\\\n/// @author Aragon Association - 2021-2023\\\\n/// @notice The abstract permission manager used in a DAO, its associated plugins, and other framework-related components.\\\\nabstract contract PermissionManager is Initializable {\\\\n    using AddressUpgradeable for address;\\\\n\\\\n    /// @notice The ID of the permission required to call the `grant`, `grantWithCondition`, `revoke`, and `bulk` function.\\\\n    bytes32 public constant ROOT_PERMISSION_ID = keccak256(\\\\\\\"ROOT_PERMISSION\\\\\\\");\\\\n\\\\n    /// @notice A special address encoding permissions that are valid for any address `who` or `where`.\\\\n    address internal constant ANY_ADDR = address(type(uint160).max);\\\\n\\\\n    /// @notice A special address encoding if a permissions is not set and therefore not allowed.\\\\n    address internal constant UNSET_FLAG = address(0);\\\\n\\\\n    /// @notice A special address encoding if a permission is allowed.\\\\n    address internal constant ALLOW_FLAG = address(2);\\\\n\\\\n    /// @notice A mapping storing permissions as hashes (i.e., `permissionHash(where, who, permissionId)`) and their status encoded by an address (unset, allowed, or redirecting to a `PermissionCondition`).\\\\n    mapping(bytes32 => address) internal permissionsHashed;\\\\n\\\\n    /// @notice Thrown if a call is unauthorized.\\\\n    /// @param where The context in which the authorization reverted.\\\\n    /// @param who The address (EOA or contract) missing the permission.\\\\n    /// @param permissionId The permission identifier.\\\\n    error Unauthorized(address where, address who, bytes32 permissionId);\\\\n\\\\n    /// @notice Thrown if a permission has been already granted with a different condition.\\\\n    /// @dev This makes sure that condition on the same permission can not be overwriten by a different condition.\\\\n    /// @param where The address of the target contract to grant `_who` permission to.\\\\n    /// @param who The address (EOA or contract) to which the permission has already been granted.\\\\n    /// @param permissionId The permission identifier.\\\\n    /// @param currentCondition The current condition set for permissionId.\\\\n    /// @param newCondition The new condition it tries to set for permissionId.\\\\n    error PermissionAlreadyGrantedForDifferentCondition(\\\\n        address where,\\\\n        address who,\\\\n        bytes32 permissionId,\\\\n        address currentCondition,\\\\n        address newCondition\\\\n    );\\\\n\\\\n    /// @notice Thrown if a condition address is not a contract.\\\\n    /// @param condition The address that is not a contract.\\\\n    error ConditionNotAContract(IPermissionCondition condition);\\\\n\\\\n    /// @notice Thrown if a condition contract does not support the `IPermissionCondition` interface.\\\\n    /// @param condition The address that is not a contract.\\\\n    error ConditionInterfacNotSupported(IPermissionCondition condition);\\\\n\\\\n    /// @notice Thrown for `ROOT_PERMISSION_ID` or `EXECUTE_PERMISSION_ID` permission grants where `who` or `where` is `ANY_ADDR`.\\\\n\\\\n    error PermissionsForAnyAddressDisallowed();\\\\n\\\\n    /// @notice Thrown for permission grants where `who` and `where` are both `ANY_ADDR`.\\\\n    error AnyAddressDisallowedForWhoAndWhere();\\\\n\\\\n    /// @notice Thrown if `Operation.GrantWithCondition` is requested as an operation but the method does not support it.\\\\n    error GrantWithConditionNotSupported();\\\\n\\\\n    /// @notice Emitted when a permission `permission` is granted in the context `here` to the address `_who` for the contract `_where`.\\\\n    /// @param permissionId The permission identifier.\\\\n    /// @param here The address of the context in which the permission is granted.\\\\n    /// @param where The address of the target contract for which `_who` receives permission.\\\\n    /// @param who The address (EOA or contract) receiving the permission.\\\\n    /// @param condition The address `ALLOW_FLAG` for regular permissions or, alternatively, the `IPermissionCondition` contract implementation to be used.\\\\n    event Granted(\\\\n        bytes32 indexed permissionId,\\\\n        address indexed here,\\\\n        address where,\\\\n        address indexed who,\\\\n        address condition\\\\n    );\\\\n\\\\n    /// @notice Emitted when a permission `permission` is revoked in the context `here` from the address `_who` for the contract `_where`.\\\\n    /// @param permissionId The permission identifier.\\\\n    /// @param here The address of the context in which the permission is revoked.\\\\n    /// @param where The address of the target contract for which `_who` loses permission.\\\\n    /// @param who The address (EOA or contract) losing the permission.\\\\n    event Revoked(\\\\n        bytes32 indexed permissionId,\\\\n        address indexed here,\\\\n        address where,\\\\n        address indexed who\\\\n    );\\\\n\\\\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through this permission manager.\\\\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\\\\n    modifier auth(bytes32 _permissionId) {\\\\n        _auth(_permissionId);\\\\n        _;\\\\n    }\\\\n\\\\n    /// @notice Initialization method to set the initial owner of the permission manager.\\\\n    /// @dev The initial owner is granted the `ROOT_PERMISSION_ID` permission.\\\\n    /// @param _initialOwner The initial owner of the permission manager.\\\\n    function __PermissionManager_init(address _initialOwner) internal onlyInitializing {\\\\n        _initializePermissionManager(_initialOwner);\\\\n    }\\\\n\\\\n    /// @notice Grants permission to an address to call methods in a contract guarded by an auth modifier with the specified permission identifier.\\\\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\\\\n    /// @param _where The address of the target contract for which `_who` receives permission.\\\\n    /// @param _who The address (EOA or contract) receiving the permission.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\\\\n    function grant(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId\\\\n    ) external virtual auth(ROOT_PERMISSION_ID) {\\\\n        _grant(_where, _who, _permissionId);\\\\n    }\\\\n\\\\n    /// @notice Grants permission to an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier if the referenced condition permits it.\\\\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission\\\\n    /// @param _where The address of the target contract for which `_who` receives permission.\\\\n    /// @param _who The address (EOA or contract) receiving the permission.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @param _condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\\\\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\\\\n    function grantWithCondition(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId,\\\\n        IPermissionCondition _condition\\\\n    ) external virtual auth(ROOT_PERMISSION_ID) {\\\\n        _grantWithCondition(_where, _who, _permissionId, _condition);\\\\n    }\\\\n\\\\n    /// @notice Revokes permission from an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier.\\\\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\\\\n    /// @param _where The address of the target contract for which `_who` loses permission.\\\\n    /// @param _who The address (EOA or contract) losing the permission.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that exist in parallel.\\\\n    function revoke(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId\\\\n    ) external virtual auth(ROOT_PERMISSION_ID) {\\\\n        _revoke(_where, _who, _permissionId);\\\\n    }\\\\n\\\\n    /// @notice Applies an array of permission operations on a single target contracts `_where`.\\\\n    /// @param _where The address of the single target contract.\\\\n    /// @param items The array of single-targeted permission operations to apply.\\\\n    function applySingleTargetPermissions(\\\\n        address _where,\\\\n        PermissionLib.SingleTargetPermission[] calldata items\\\\n    ) external virtual auth(ROOT_PERMISSION_ID) {\\\\n        for (uint256 i; i < items.length; ) {\\\\n            PermissionLib.SingleTargetPermission memory item = items[i];\\\\n\\\\n            if (item.operation == PermissionLib.Operation.Grant) {\\\\n                _grant(_where, item.who, item.permissionId);\\\\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\\\\n                _revoke(_where, item.who, item.permissionId);\\\\n            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {\\\\n                revert GrantWithConditionNotSupported();\\\\n            }\\\\n\\\\n            unchecked {\\\\n                ++i;\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Applies an array of permission operations on multiple target contracts `items[i].where`.\\\\n    /// @param _items The array of multi-targeted permission operations to apply.\\\\n    function applyMultiTargetPermissions(\\\\n        PermissionLib.MultiTargetPermission[] calldata _items\\\\n    ) external virtual auth(ROOT_PERMISSION_ID) {\\\\n        for (uint256 i; i < _items.length; ) {\\\\n            PermissionLib.MultiTargetPermission memory item = _items[i];\\\\n\\\\n            if (item.operation == PermissionLib.Operation.Grant) {\\\\n                _grant(item.where, item.who, item.permissionId);\\\\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\\\\n                _revoke(item.where, item.who, item.permissionId);\\\\n            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {\\\\n                _grantWithCondition(\\\\n                    item.where,\\\\n                    item.who,\\\\n                    item.permissionId,\\\\n                    IPermissionCondition(item.condition)\\\\n                );\\\\n            }\\\\n\\\\n            unchecked {\\\\n                ++i;\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\\\\n    /// @param _where The address of the target contract for which `_who` receives permission.\\\\n    /// @param _who The address (EOA or contract) for which the permission is checked.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\\\\n    /// @return Returns true if `_who` has the permissions on the target contract via the specified permission identifier.\\\\n    function isGranted(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId,\\\\n        bytes memory _data\\\\n    ) public view virtual returns (bool) {\\\\n        return\\\\n            _isGranted(_where, _who, _permissionId, _data) || // check if `_who` has permission for `_permissionId` on `_where`\\\\n            _isGranted(_where, ANY_ADDR, _permissionId, _data) || // check if anyone has permission for `_permissionId` on `_where`\\\\n            _isGranted(ANY_ADDR, _who, _permissionId, _data); // check if `_who` has permission for `_permissionI` on any contract\\\\n    }\\\\n\\\\n    /// @notice Grants the `ROOT_PERMISSION_ID` permission to the initial owner during initialization of the permission manager.\\\\n    /// @param _initialOwner The initial owner of the permission manager.\\\\n    function _initializePermissionManager(address _initialOwner) internal {\\\\n        _grant(address(this), _initialOwner, ROOT_PERMISSION_ID);\\\\n    }\\\\n\\\\n    /// @notice This method is used in the external `grant` method of the permission manager.\\\\n    /// @param _where The address of the target contract for which `_who` receives permission.\\\\n    /// @param _who The address (EOA or contract) owning the permission.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\\\\n    function _grant(address _where, address _who, bytes32 _permissionId) internal virtual {\\\\n        if (_where == ANY_ADDR || _who == ANY_ADDR) {\\\\n            revert PermissionsForAnyAddressDisallowed();\\\\n        }\\\\n\\\\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\\\\n\\\\n        address currentFlag = permissionsHashed[permHash];\\\\n\\\\n        // Means permHash is not currently set.\\\\n        if (currentFlag == UNSET_FLAG) {\\\\n            permissionsHashed[permHash] = ALLOW_FLAG;\\\\n\\\\n            emit Granted(_permissionId, msg.sender, _where, _who, ALLOW_FLAG);\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice This method is used in the external `grantWithCondition` method of the permission manager.\\\\n    /// @param _where The address of the target contract for which `_who` receives permission.\\\\n    /// @param _who The address (EOA or contract) owning the permission.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @param _condition An address either resolving to a `PermissionCondition` contract address or being the `ALLOW_FLAG` address (`address(2)`).\\\\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\\\\n    function _grantWithCondition(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId,\\\\n        IPermissionCondition _condition\\\\n    ) internal virtual {\\\\n        address conditionAddr = address(_condition);\\\\n\\\\n        if (!conditionAddr.isContract()) {\\\\n            revert ConditionNotAContract(_condition);\\\\n        }\\\\n\\\\n        if (\\\\n            !PermissionCondition(conditionAddr).supportsInterface(\\\\n                type(IPermissionCondition).interfaceId\\\\n            )\\\\n        ) {\\\\n            revert ConditionInterfacNotSupported(_condition);\\\\n        }\\\\n\\\\n        if (_where == ANY_ADDR && _who == ANY_ADDR) {\\\\n            revert AnyAddressDisallowedForWhoAndWhere();\\\\n        }\\\\n\\\\n        if (_where == ANY_ADDR || _who == ANY_ADDR) {\\\\n            if (\\\\n                _permissionId == ROOT_PERMISSION_ID ||\\\\n                isPermissionRestrictedForAnyAddr(_permissionId)\\\\n            ) {\\\\n                revert PermissionsForAnyAddressDisallowed();\\\\n            }\\\\n        }\\\\n\\\\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\\\\n\\\\n        address currentCondition = permissionsHashed[permHash];\\\\n\\\\n        // Means permHash is not currently set.\\\\n        if (currentCondition == UNSET_FLAG) {\\\\n            permissionsHashed[permHash] = conditionAddr;\\\\n\\\\n            emit Granted(_permissionId, msg.sender, _where, _who, conditionAddr);\\\\n        } else if (currentCondition != conditionAddr) {\\\\n            // Revert if `permHash` is already granted, but uses a different condition.\\\\n            // If we don't revert, we either should:\\\\n            //   - allow overriding the condition on the same permission\\\\n            //     which could be confusing whoever granted the same permission first\\\\n            //   - or do nothing and succeed silently which could be confusing for the caller.\\\\n            revert PermissionAlreadyGrantedForDifferentCondition({\\\\n                where: _where,\\\\n                who: _who,\\\\n                permissionId: _permissionId,\\\\n                currentCondition: currentCondition,\\\\n                newCondition: conditionAddr\\\\n            });\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice This method is used in the public `revoke` method of the permission manager.\\\\n    /// @param _where The address of the target contract for which `_who` receives permission.\\\\n    /// @param _who The address (EOA or contract) owning the permission.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that might have been granted in parallel.\\\\n    function _revoke(address _where, address _who, bytes32 _permissionId) internal virtual {\\\\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\\\\n        if (permissionsHashed[permHash] != UNSET_FLAG) {\\\\n            permissionsHashed[permHash] = UNSET_FLAG;\\\\n\\\\n            emit Revoked(_permissionId, msg.sender, _where, _who);\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Checks if a caller is granted permissions on a target contract via a permission identifier and redirects the approval to a `PermissionCondition` if this was specified in the setup.\\\\n    /// @param _where The address of the target contract for which `_who` receives permission.\\\\n    /// @param _who The address (EOA or contract) owning the permission.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\\\\n    /// @return Returns true if `_who` has the permissions on the contract via the specified permissionId identifier.\\\\n    function _isGranted(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId,\\\\n        bytes memory _data\\\\n    ) internal view virtual returns (bool) {\\\\n        address accessFlagOrCondition = permissionsHashed[\\\\n            permissionHash(_where, _who, _permissionId)\\\\n        ];\\\\n\\\\n        if (accessFlagOrCondition == UNSET_FLAG) return false;\\\\n        if (accessFlagOrCondition == ALLOW_FLAG) return true;\\\\n\\\\n        // Since it's not a flag, assume it's a PermissionCondition and try-catch to skip failures\\\\n        try\\\\n            IPermissionCondition(accessFlagOrCondition).isGranted(\\\\n                _where,\\\\n                _who,\\\\n                _permissionId,\\\\n                _data\\\\n            )\\\\n        returns (bool allowed) {\\\\n            if (allowed) return true;\\\\n        } catch {}\\\\n\\\\n        return false;\\\\n    }\\\\n\\\\n    /// @notice A private function to be used to check permissions on the permission manager contract (`address(this)`) itself.\\\\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\\\\n    function _auth(bytes32 _permissionId) internal view virtual {\\\\n        if (!isGranted(address(this), msg.sender, _permissionId, msg.data)) {\\\\n            revert Unauthorized({\\\\n                where: address(this),\\\\n                who: msg.sender,\\\\n                permissionId: _permissionId\\\\n            });\\\\n        }\\\\n    }\\\\n\\\\n    /// @notice Generates the hash for the `permissionsHashed` mapping obtained from the word \\\\\\\"PERMISSION\\\\\\\", the contract address, the address owning the permission, and the permission identifier.\\\\n    /// @param _where The address of the target contract for which `_who` receives permission.\\\\n    /// @param _who The address (EOA or contract) owning the permission.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @return The permission hash.\\\\n    function permissionHash(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId\\\\n    ) internal pure virtual returns (bytes32) {\\\\n        return keccak256(abi.encodePacked(\\\\\\\"PERMISSION\\\\\\\", _who, _where, _permissionId));\\\\n    }\\\\n\\\\n    /// @notice Decides if the granting permissionId is restricted when `_who == ANY_ADDR` or `_where == ANY_ADDR`.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @return Whether or not the permission is restricted.\\\\n    /// @dev By default, every permission is unrestricted and it is the derived contract's responsibility to override it. Note, that the `ROOT_PERMISSION_ID` is included and not required to be set it again.\\\\n    function isPermissionRestrictedForAnyAddr(\\\\n        bytes32 _permissionId\\\\n    ) internal view virtual returns (bool) {\\\\n        (_permissionId); // silence the warning.\\\\n        return false;\\\\n    }\\\\n\\\\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\\\\n    uint256[49] private __gap;\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/utils/CallbackHandler.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity 0.8.17;\\\\n\\\\n/// @title CallbackHandler\\\\n/// @author Aragon Association - 2022-2023\\\\n/// @notice This contract handles callbacks by registering a magic number together with the callback function's selector. It provides the `_handleCallback` function that inheriting contracts have to call inside their `fallback()` function  (`_handleCallback(msg.callbackSelector, msg.data)`).  This allows to adaptively register ERC standards (e.g., [ERC-721](https://eips.ethereum.org/EIPS/eip-721), [ERC-1115](https://eips.ethereum.org/EIPS/eip-1155), or future versions of [ERC-165](https://eips.ethereum.org/EIPS/eip-165)) and returning the required magic numbers for the associated callback functions for the inheriting contract so that it doesn't need to be upgraded.\\\\n/// @dev This callback handling functionality is intented to be used by executor contracts (i.e., `DAO.sol`).\\\\nabstract contract CallbackHandler {\\\\n    /// @notice A mapping between callback function selectors and magic return numbers.\\\\n    mapping(bytes4 => bytes4) internal callbackMagicNumbers;\\\\n\\\\n    /// @notice The magic number refering to unregistered callbacks.\\\\n    bytes4 internal constant UNREGISTERED_CALLBACK = bytes4(0);\\\\n\\\\n    /// @notice Thrown if the callback function is not registered.\\\\n    /// @param callbackSelector The selector of the callback function.\\\\n    /// @param magicNumber The magic number to be registered for the callback function selector.\\\\n    error UnkownCallback(bytes4 callbackSelector, bytes4 magicNumber);\\\\n\\\\n    /// @notice Emitted when `_handleCallback` is called.\\\\n    /// @param sender Who called the callback.\\\\n    /// @param sig The function signature.\\\\n    /// @param data The calldata.\\\\n    event CallbackReceived(address sender, bytes4 indexed sig, bytes data);\\\\n\\\\n    /// @notice Handles callbacks to adaptively support ERC standards.\\\\n    /// @dev This function is supposed to be called via `_handleCallback(msg.sig, msg.data)` in the `fallback()` function of the inheriting contract.\\\\n    /// @param _callbackSelector The function selector of the callback function.\\\\n    /// @param _data The calldata.\\\\n    /// @return The magic number registered for the function selector triggering the fallback.\\\\n    function _handleCallback(\\\\n        bytes4 _callbackSelector,\\\\n        bytes memory _data\\\\n    ) internal virtual returns (bytes4) {\\\\n        bytes4 magicNumber = callbackMagicNumbers[_callbackSelector];\\\\n        if (magicNumber == UNREGISTERED_CALLBACK) {\\\\n            revert UnkownCallback({callbackSelector: _callbackSelector, magicNumber: magicNumber});\\\\n        }\\\\n\\\\n        emit CallbackReceived({sender: msg.sender, sig: _callbackSelector, data: _data});\\\\n\\\\n        return magicNumber;\\\\n    }\\\\n\\\\n    /// @notice Registers a magic number for a callback function selector.\\\\n    /// @param _callbackSelector The selector of the callback function.\\\\n    /// @param _magicNumber The magic number to be registered for the callback function selector.\\\\n    function _registerCallback(bytes4 _callbackSelector, bytes4 _magicNumber) internal virtual {\\\\n        callbackMagicNumbers[_callbackSelector] = _magicNumber;\\\\n    }\\\\n\\\\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\\\\n    uint256[49] private __gap;\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/utils/BitMap.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity 0.8.17;\\\\n\\\\n/// @param bitmap The `uint256` representation of bits.\\\\n/// @param index The index number to check whether 1 or 0 is set.\\\\n/// @return Returns `true` if the bit is set at `index` on `bitmap`.\\\\nfunction hasBit(uint256 bitmap, uint8 index) pure returns (bool) {\\\\n    uint256 bitValue = bitmap & (1 << index);\\\\n    return bitValue > 0;\\\\n}\\\\n\\\\n/// @param bitmap The `uint256` representation of bits.\\\\n/// @param index The index number to set the bit.\\\\n/// @return Returns a new number in which the bit is set at `index`.\\\\nfunction flipBit(uint256 bitmap, uint8 index) pure returns (uint256) {\\\\n    return bitmap ^ (1 << index);\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/dao/IEIP4824.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity 0.8.17;\\\\n\\\\n/// @title EIP-4824 Common Interfaces for DAOs\\\\n/// @dev See https://eips.ethereum.org/EIPS/eip-4824\\\\n/// @author Aragon Association - 2021-2023\\\\ninterface IEIP4824 {\\\\n    /// @notice A distinct Uniform Resource Identifier (URI) pointing to a JSON object following the \\\\\\\"EIP-4824 DAO JSON-LD Schema\\\\\\\". This JSON file splits into four URIs: membersURI, proposalsURI, activityLogURI, and governanceURI. The membersURI should point to a JSON file that conforms to the \\\\\\\"EIP-4824 Members JSON-LD Schema\\\\\\\". The proposalsURI should point to a JSON file that conforms to the \\\\\\\"EIP-4824 Proposals JSON-LD Schema\\\\\\\". The activityLogURI should point to a JSON file that conforms to the \\\\\\\"EIP-4824 Activity Log JSON-LD Schema\\\\\\\". The governanceURI should point to a flatfile, normatively a .md file. Each of the JSON files named above can be statically hosted or dynamically-generated.\\\\n    /// @return _daoURI The DAO URI.\\\\n    function daoURI() external view returns (string memory _daoURI);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"../Proxy.sol\\\\\\\";\\\\nimport \\\\\\\"./ERC1967Upgrade.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\\\n * implementation behind the proxy.\\\\n */\\\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\\\n    /**\\\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\\\n     *\\\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\\\n     */\\\\n    constructor(address _logic, bytes memory _data) payable {\\\\n        _upgradeToAndCall(_logic, _data, false);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the current implementation address.\\\\n     */\\\\n    function _implementation() internal view virtual override returns (address impl) {\\\\n        return ERC1967Upgrade._getImplementation();\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC165 standard, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\\\n *\\\\n * Implementers can declare support of contract interfaces, which can then be\\\\n * queried by others ({ERC165Checker}).\\\\n *\\\\n * For an implementation, see {ERC165}.\\\\n */\\\\ninterface IERC165 {\\\\n    /**\\\\n     * @dev Returns true if this contract implements the interface defined by\\\\n     * `interfaceId`. See the corresponding\\\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\\\n     * to learn more about how these ids are created.\\\\n     *\\\\n     * This function call must use less than 30 000 gas.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\\\n * proxy whose upgrades are fully controlled by the current implementation.\\\\n */\\\\ninterface IERC1822ProxiableUpgradeable {\\\\n    /**\\\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\\\n     * address.\\\\n     *\\\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\\\n     * function revert if invoked through a proxy.\\\\n     */\\\\n    function proxiableUUID() external view returns (bytes32);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\\"./IERC165Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../../proxy/utils/Initializable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of the {IERC165} interface.\\\\n *\\\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\\\n * for the additional interface id that will be supported. For example:\\\\n *\\\\n * ```solidity\\\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\\\n * }\\\\n * ```\\\\n *\\\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\\\n */\\\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\\\n    function __ERC165_init() internal onlyInitializing {\\\\n    }\\\\n\\\\n    function __ERC165_init_unchained() internal onlyInitializing {\\\\n    }\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\\\n     * variables without shifting down storage in the inheritance chain.\\\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\\\n     */\\\\n    uint256[50] private __gap;\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/plugin/dao-authorizable/DaoAuthorizableUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\nimport {ContextUpgradeable} from \\\\\\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\\\\\";\\\\n\\\\nimport {IDAO} from \\\\\\\"../../dao/IDAO.sol\\\\\\\";\\\\nimport {_auth} from \\\\\\\"../../utils/auth.sol\\\\\\\";\\\\n\\\\n/// @title DaoAuthorizableUpgradeable\\\\n/// @author Aragon Association - 2022-2023\\\\n/// @notice An abstract contract providing a meta-transaction compatible modifier for upgradeable or cloneable contracts to authorize function calls through an associated DAO.\\\\n/// @dev Make sure to call `__DaoAuthorizableUpgradeable_init` during initialization of the inheriting contract.\\\\nabstract contract DaoAuthorizableUpgradeable is ContextUpgradeable {\\\\n    /// @notice The associated DAO managing the permissions of inheriting contracts.\\\\n    IDAO private dao_;\\\\n\\\\n    /// @notice Initializes the contract by setting the associated DAO.\\\\n    /// @param _dao The associated DAO address.\\\\n    function __DaoAuthorizableUpgradeable_init(IDAO _dao) internal onlyInitializing {\\\\n        dao_ = _dao;\\\\n    }\\\\n\\\\n    /// @notice Returns the DAO contract.\\\\n    /// @return The DAO contract.\\\\n    function dao() public view returns (IDAO) {\\\\n        return dao_;\\\\n    }\\\\n\\\\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through the associated DAO's permission manager.\\\\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\\\\n    modifier auth(bytes32 _permissionId) {\\\\n        _auth(dao_, address(this), _msgSender(), _permissionId, _msgData());\\\\n        _;\\\\n    }\\\\n\\\\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\\\\n    uint256[49] private __gap;\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/plugin/IPlugin.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\n/// @title IPlugin\\\\n/// @author Aragon Association - 2022-2023\\\\n/// @notice An interface defining the traits of a plugin.\\\\ninterface IPlugin {\\\\n    enum PluginType {\\\\n        UUPS,\\\\n        Cloneable,\\\\n        Constructable\\\\n    }\\\\n\\\\n    /// @notice Returns the plugin's type\\\\n    function pluginType() external view returns (PluginType);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\\\n *\\\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\\\n * need to send a transaction, and thus is not required to hold Ether at all.\\\\n */\\\\ninterface IERC20Permit {\\\\n    /**\\\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\\\n     * given ``owner``'s signed approval.\\\\n     *\\\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\\\n     * ordering also apply here.\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `spender` cannot be the zero address.\\\\n     * - `deadline` must be a timestamp in the future.\\\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\\\n     * over the EIP712-formatted function arguments.\\\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\\\n     *\\\\n     * For more information on the signature format, see the\\\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\\\n     * section].\\\\n     */\\\\n    function permit(\\\\n        address owner,\\\\n        address spender,\\\\n        uint256 value,\\\\n        uint256 deadline,\\\\n        uint8 v,\\\\n        bytes32 r,\\\\n        bytes32 s\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @dev Returns the current nonce for `owner`. This value must be\\\\n     * included whenever a signature is generated for {permit}.\\\\n     *\\\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\\\n     * prevents a signature from being used multiple times.\\\\n     */\\\\n    function nonces(address owner) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\\\n     */\\\\n    // solhint-disable-next-line func-name-mixedcase\\\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/utils/Address.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\\\n\\\\npragma solidity ^0.8.1;\\\\n\\\\n/**\\\\n * @dev Collection of functions related to the address type\\\\n */\\\\nlibrary Address {\\\\n    /**\\\\n     * @dev Returns true if `account` is a contract.\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * It is unsafe to assume that an address for which this function returns\\\\n     * false is an externally-owned account (EOA) and not a contract.\\\\n     *\\\\n     * Among others, `isContract` will return false for the following\\\\n     * types of addresses:\\\\n     *\\\\n     *  - an externally-owned account\\\\n     *  - a contract in construction\\\\n     *  - an address where a contract will be created\\\\n     *  - an address where a contract lived, but was destroyed\\\\n     *\\\\n     * Furthermore, `isContract` will also return true if the target contract within\\\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\\\n     * which only has an effect at the end of a transaction.\\\\n     * ====\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\\\n     *\\\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\\\n     * constructor.\\\\n     * ====\\\\n     */\\\\n    function isContract(address account) internal view returns (bool) {\\\\n        // This method relies on extcodesize/address.code.length, which returns 0\\\\n        // for contracts in construction, since the code is only stored at the end\\\\n        // of the constructor execution.\\\\n\\\\n        return account.code.length > 0;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\\\n     * `recipient`, forwarding all available gas and reverting on errors.\\\\n     *\\\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\\\n     * imposed by `transfer`, making them unable to receive funds via\\\\n     * `transfer`. {sendValue} removes this limitation.\\\\n     *\\\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\\\n     *\\\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\\\n     * taken to not create reentrancy vulnerabilities. Consider using\\\\n     * {ReentrancyGuard} or the\\\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\\\n     */\\\\n    function sendValue(address payable recipient, uint256 amount) internal {\\\\n        require(address(this).balance >= amount, \\\\\\\"Address: insufficient balance\\\\\\\");\\\\n\\\\n        (bool success, ) = recipient.call{value: amount}(\\\\\\\"\\\\\\\");\\\\n        require(success, \\\\\\\"Address: unable to send value, recipient may have reverted\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Performs a Solidity function call using a low level `call`. A\\\\n     * plain `call` is an unsafe replacement for a function call: use this\\\\n     * function instead.\\\\n     *\\\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\\\n     * function (like regular Solidity function calls).\\\\n     *\\\\n     * Returns the raw returned data. To convert to the expected return value,\\\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `target` must be a contract.\\\\n     * - calling `target` with `data` must not revert.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, \\\\\\\"Address: low-level call failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but also transferring `value` wei to `target`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - the calling contract must have an ETH balance of at least `value`.\\\\n     * - the called Solidity function must be `payable`.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, value, \\\\\\\"Address: low-level call with value failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(\\\\n        address target,\\\\n        bytes memory data,\\\\n        uint256 value,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        require(address(this).balance >= value, \\\\\\\"Address: insufficient balance for call\\\\\\\");\\\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\\\n        return functionStaticCall(target, data, \\\\\\\"Address: low-level static call failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionDelegateCall(target, data, \\\\\\\"Address: low-level delegate call failed\\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\\\n     *\\\\n     * _Available since v4.8._\\\\n     */\\\\n    function verifyCallResultFromTarget(\\\\n        address target,\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        if (success) {\\\\n            if (returndata.length == 0) {\\\\n                // only check isContract if the call was successful and the return data is empty\\\\n                // otherwise we already know that it was a contract\\\\n                require(isContract(target), \\\\\\\"Address: call to non-contract\\\\\\\");\\\\n            }\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\\\n     * revert reason or using the provided one.\\\\n     *\\\\n     * _Available since v4.3._\\\\n     */\\\\n    function verifyCallResult(\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal pure returns (bytes memory) {\\\\n        if (success) {\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\\\n        // Look for revert reason and bubble it up if present\\\\n        if (returndata.length > 0) {\\\\n            // The easiest way to bubble the revert reason is using memory via assembly\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                let returndata_size := mload(returndata)\\\\n                revert(add(32, returndata), returndata_size)\\\\n            }\\\\n        } else {\\\\n            revert(errorMessage);\\\\n        }\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\\\n\\\\npragma solidity ^0.8.2;\\\\n\\\\nimport \\\\\\\"../beacon/IBeaconUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../../interfaces/IERC1967Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../../utils/AddressUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../../utils/StorageSlotUpgradeable.sol\\\\\\\";\\\\nimport \\\\\\\"../utils/Initializable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev This abstract contract provides getters and event emitting update functions for\\\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\\\n *\\\\n * _Available since v4.1._\\\\n */\\\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\\\n    }\\\\n\\\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\\\n    }\\\\n    // This is the keccak-256 hash of \\\\\\\"eip1967.proxy.rollback\\\\\\\" subtracted by 1\\\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\\\n\\\\n    /**\\\\n     * @dev Storage slot with the address of the current implementation.\\\\n     * This is the keccak-256 hash of \\\\\\\"eip1967.proxy.implementation\\\\\\\" subtracted by 1, and is\\\\n     * validated in the constructor.\\\\n     */\\\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\\\n\\\\n    /**\\\\n     * @dev Returns the current implementation address.\\\\n     */\\\\n    function _getImplementation() internal view returns (address) {\\\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\\\n     */\\\\n    function _setImplementation(address newImplementation) private {\\\\n        require(AddressUpgradeable.isContract(newImplementation), \\\\\\\"ERC1967: new implementation is not a contract\\\\\\\");\\\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Perform implementation upgrade\\\\n     *\\\\n     * Emits an {Upgraded} event.\\\\n     */\\\\n    function _upgradeTo(address newImplementation) internal {\\\\n        _setImplementation(newImplementation);\\\\n        emit Upgraded(newImplementation);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Perform implementation upgrade with additional setup call.\\\\n     *\\\\n     * Emits an {Upgraded} event.\\\\n     */\\\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\\\n        _upgradeTo(newImplementation);\\\\n        if (data.length > 0 || forceCall) {\\\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\\\n     *\\\\n     * Emits an {Upgraded} event.\\\\n     */\\\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\\\n            _setImplementation(newImplementation);\\\\n        } else {\\\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\\\n                require(slot == _IMPLEMENTATION_SLOT, \\\\\\\"ERC1967Upgrade: unsupported proxiableUUID\\\\\\\");\\\\n            } catch {\\\\n                revert(\\\\\\\"ERC1967Upgrade: new implementation is not UUPS\\\\\\\");\\\\n            }\\\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Storage slot with the admin of the contract.\\\\n     * This is the keccak-256 hash of \\\\\\\"eip1967.proxy.admin\\\\\\\" subtracted by 1, and is\\\\n     * validated in the constructor.\\\\n     */\\\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\\\n\\\\n    /**\\\\n     * @dev Returns the current admin.\\\\n     */\\\\n    function _getAdmin() internal view returns (address) {\\\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Stores a new address in the EIP1967 admin slot.\\\\n     */\\\\n    function _setAdmin(address newAdmin) private {\\\\n        require(newAdmin != address(0), \\\\\\\"ERC1967: new admin is the zero address\\\\\\\");\\\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Changes the admin of the proxy.\\\\n     *\\\\n     * Emits an {AdminChanged} event.\\\\n     */\\\\n    function _changeAdmin(address newAdmin) internal {\\\\n        emit AdminChanged(_getAdmin(), newAdmin);\\\\n        _setAdmin(newAdmin);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\\\n     */\\\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\\\n\\\\n    /**\\\\n     * @dev Returns the current beacon.\\\\n     */\\\\n    function _getBeacon() internal view returns (address) {\\\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\\\n     */\\\\n    function _setBeacon(address newBeacon) private {\\\\n        require(AddressUpgradeable.isContract(newBeacon), \\\\\\\"ERC1967: new beacon is not a contract\\\\\\\");\\\\n        require(\\\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\\\n            \\\\\\\"ERC1967: beacon implementation is not a contract\\\\\\\"\\\\n        );\\\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\\\n     *\\\\n     * Emits a {BeaconUpgraded} event.\\\\n     */\\\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\\\n        _setBeacon(newBeacon);\\\\n        emit BeaconUpgraded(newBeacon);\\\\n        if (data.length > 0 || forceCall) {\\\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\\\n     * variables without shifting down storage in the inheritance chain.\\\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\\\n     */\\\\n    uint256[50] private __gap;\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\\\n *\\\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\\\n * need to send a transaction, and thus is not required to hold Ether at all.\\\\n */\\\\ninterface IERC20PermitUpgradeable {\\\\n    /**\\\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\\\n     * given ``owner``'s signed approval.\\\\n     *\\\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\\\n     * ordering also apply here.\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `spender` cannot be the zero address.\\\\n     * - `deadline` must be a timestamp in the future.\\\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\\\n     * over the EIP712-formatted function arguments.\\\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\\\n     *\\\\n     * For more information on the signature format, see the\\\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\\\n     * section].\\\\n     */\\\\n    function permit(\\\\n        address owner,\\\\n        address spender,\\\\n        uint256 value,\\\\n        uint256 deadline,\\\\n        uint8 v,\\\\n        bytes32 r,\\\\n        bytes32 s\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @dev Returns the current nonce for `owner`. This value must be\\\\n     * included whenever a signature is generated for {permit}.\\\\n     *\\\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\\\n     * prevents a signature from being used multiple times.\\\\n     */\\\\n    function nonces(address owner) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\\\n     */\\\\n    // solhint-disable-next-line func-name-mixedcase\\\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC165 standard, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\\\n *\\\\n * Implementers can declare support of contract interfaces, which can then be\\\\n * queried by others ({ERC165Checker}).\\\\n *\\\\n * For an implementation, see {ERC165}.\\\\n */\\\\ninterface IERC165Upgradeable {\\\\n    /**\\\\n     * @dev Returns true if this contract implements the interface defined by\\\\n     * `interfaceId`. See the corresponding\\\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\\\n     * to learn more about how these ids are created.\\\\n     *\\\\n     * This function call must use less than 30 000 gas.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/permission/IPermissionCondition.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\n/// @title IPermissionCondition\\\\n/// @author Aragon Association - 2021-2023\\\\n/// @notice An interface to be implemented to support custom permission logic.\\\\n/// @dev To attach a condition to a permission, the `grantWithCondition` function must be used and refer to the implementing contract's address with the `condition` argument.\\\\ninterface IPermissionCondition {\\\\n    /// @notice Checks if a call is permitted.\\\\n    /// @param _where The address of the target contract.\\\\n    /// @param _who The address (EOA or contract) for which the permissions are checked.\\\\n    /// @param _permissionId The permission identifier.\\\\n    /// @param _data Optional data passed to the `PermissionCondition` implementation.\\\\n    /// @return isPermitted Returns true if the call is permitted.\\\\n    function isGranted(\\\\n        address _where,\\\\n        address _who,\\\\n        bytes32 _permissionId,\\\\n        bytes calldata _data\\\\n    ) external view returns (bool isPermitted);\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/permission/PermissionCondition.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\nimport {ERC165} from \\\\\\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\\\\\";\\\\n\\\\nimport {IPermissionCondition} from \\\\\\\"./IPermissionCondition.sol\\\\\\\";\\\\n\\\\n/// @title PermissionCondition\\\\n/// @author Aragon Association - 2023\\\\n/// @notice An abstract contract for non-upgradeable contracts instantiated via the `new` keyword  to inherit from to support customary permissions depending on arbitrary on-chain state.\\\\nabstract contract PermissionCondition is ERC165, IPermissionCondition {\\\\n    /// @notice Checks if an interface is supported by this or its parent contract.\\\\n    /// @param _interfaceId The ID of the interface.\\\\n    /// @return Returns `true` if the interface is supported.\\\\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\\\n        return\\\\n            _interfaceId == type(IPermissionCondition).interfaceId ||\\\\n            super.supportsInterface(_interfaceId);\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/proxy/Proxy.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\\\n * be specified by overriding the virtual {_implementation} function.\\\\n *\\\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\\\n * different contract through the {_delegate} function.\\\\n *\\\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\\\n */\\\\nabstract contract Proxy {\\\\n    /**\\\\n     * @dev Delegates the current call to `implementation`.\\\\n     *\\\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\\\n     */\\\\n    function _delegate(address implementation) internal virtual {\\\\n        assembly {\\\\n            // Copy msg.data. We take full control of memory in this inline assembly\\\\n            // block because it will not return to Solidity code. We overwrite the\\\\n            // Solidity scratch pad at memory position 0.\\\\n            calldatacopy(0, 0, calldatasize())\\\\n\\\\n            // Call the implementation.\\\\n            // out and outsize are 0 because we don't know the size yet.\\\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\\\n\\\\n            // Copy the returned data.\\\\n            returndatacopy(0, 0, returndatasize())\\\\n\\\\n            switch result\\\\n            // delegatecall returns 0 on error.\\\\n            case 0 {\\\\n                revert(0, returndatasize())\\\\n            }\\\\n            default {\\\\n                return(0, returndatasize())\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\\\n     * and {_fallback} should delegate.\\\\n     */\\\\n    function _implementation() internal view virtual returns (address);\\\\n\\\\n    /**\\\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\\\n     *\\\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\\\n     */\\\\n    function _fallback() internal virtual {\\\\n        _beforeFallback();\\\\n        _delegate(_implementation());\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\\\n     * function in the contract matches the call data.\\\\n     */\\\\n    fallback() external payable virtual {\\\\n        _fallback();\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\\\n     * is empty.\\\\n     */\\\\n    receive() external payable virtual {\\\\n        _fallback();\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\\\n     *\\\\n     * If overridden should call `super._beforeFallback()`.\\\\n     */\\\\n    function _beforeFallback() internal virtual {}\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\\\n\\\\npragma solidity ^0.8.2;\\\\n\\\\nimport \\\\\\\"../beacon/IBeacon.sol\\\\\\\";\\\\nimport \\\\\\\"../../interfaces/IERC1967.sol\\\\\\\";\\\\nimport \\\\\\\"../../interfaces/draft-IERC1822.sol\\\\\\\";\\\\nimport \\\\\\\"../../utils/Address.sol\\\\\\\";\\\\nimport \\\\\\\"../../utils/StorageSlot.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev This abstract contract provides getters and event emitting update functions for\\\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\\\n *\\\\n * _Available since v4.1._\\\\n */\\\\nabstract contract ERC1967Upgrade is IERC1967 {\\\\n    // This is the keccak-256 hash of \\\\\\\"eip1967.proxy.rollback\\\\\\\" subtracted by 1\\\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\\\n\\\\n    /**\\\\n     * @dev Storage slot with the address of the current implementation.\\\\n     * This is the keccak-256 hash of \\\\\\\"eip1967.proxy.implementation\\\\\\\" subtracted by 1, and is\\\\n     * validated in the constructor.\\\\n     */\\\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\\\n\\\\n    /**\\\\n     * @dev Returns the current implementation address.\\\\n     */\\\\n    function _getImplementation() internal view returns (address) {\\\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\\\n     */\\\\n    function _setImplementation(address newImplementation) private {\\\\n        require(Address.isContract(newImplementation), \\\\\\\"ERC1967: new implementation is not a contract\\\\\\\");\\\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Perform implementation upgrade\\\\n     *\\\\n     * Emits an {Upgraded} event.\\\\n     */\\\\n    function _upgradeTo(address newImplementation) internal {\\\\n        _setImplementation(newImplementation);\\\\n        emit Upgraded(newImplementation);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Perform implementation upgrade with additional setup call.\\\\n     *\\\\n     * Emits an {Upgraded} event.\\\\n     */\\\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\\\n        _upgradeTo(newImplementation);\\\\n        if (data.length > 0 || forceCall) {\\\\n            Address.functionDelegateCall(newImplementation, data);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\\\n     *\\\\n     * Emits an {Upgraded} event.\\\\n     */\\\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\\\n            _setImplementation(newImplementation);\\\\n        } else {\\\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\\\n                require(slot == _IMPLEMENTATION_SLOT, \\\\\\\"ERC1967Upgrade: unsupported proxiableUUID\\\\\\\");\\\\n            } catch {\\\\n                revert(\\\\\\\"ERC1967Upgrade: new implementation is not UUPS\\\\\\\");\\\\n            }\\\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Storage slot with the admin of the contract.\\\\n     * This is the keccak-256 hash of \\\\\\\"eip1967.proxy.admin\\\\\\\" subtracted by 1, and is\\\\n     * validated in the constructor.\\\\n     */\\\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\\\n\\\\n    /**\\\\n     * @dev Returns the current admin.\\\\n     */\\\\n    function _getAdmin() internal view returns (address) {\\\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Stores a new address in the EIP1967 admin slot.\\\\n     */\\\\n    function _setAdmin(address newAdmin) private {\\\\n        require(newAdmin != address(0), \\\\\\\"ERC1967: new admin is the zero address\\\\\\\");\\\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Changes the admin of the proxy.\\\\n     *\\\\n     * Emits an {AdminChanged} event.\\\\n     */\\\\n    function _changeAdmin(address newAdmin) internal {\\\\n        emit AdminChanged(_getAdmin(), newAdmin);\\\\n        _setAdmin(newAdmin);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\\\n     */\\\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\\\n\\\\n    /**\\\\n     * @dev Returns the current beacon.\\\\n     */\\\\n    function _getBeacon() internal view returns (address) {\\\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\\\n     */\\\\n    function _setBeacon(address newBeacon) private {\\\\n        require(Address.isContract(newBeacon), \\\\\\\"ERC1967: new beacon is not a contract\\\\\\\");\\\\n        require(\\\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\\\n            \\\\\\\"ERC1967: beacon implementation is not a contract\\\\\\\"\\\\n        );\\\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\\\n     *\\\\n     * Emits a {BeaconUpgraded} event.\\\\n     */\\\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\\\n        _setBeacon(newBeacon);\\\\n        emit BeaconUpgraded(newBeacon);\\\\n        if (data.length > 0 || forceCall) {\\\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\\\n        }\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\nimport \\\\\\\"../proxy/utils/Initializable.sol\\\\\\\";\\\\n\\\\n/**\\\\n * @dev Provides information about the current execution context, including the\\\\n * sender of the transaction and its data. While these are generally available\\\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\\\n * manner, since when dealing with meta-transactions the account sending and\\\\n * paying for execution may not be the actual sender (as far as an application\\\\n * is concerned).\\\\n *\\\\n * This contract is only required for intermediate, library-like contracts.\\\\n */\\\\nabstract contract ContextUpgradeable is Initializable {\\\\n    function __Context_init() internal onlyInitializing {\\\\n    }\\\\n\\\\n    function __Context_init_unchained() internal onlyInitializing {\\\\n    }\\\\n    function _msgSender() internal view virtual returns (address) {\\\\n        return msg.sender;\\\\n    }\\\\n\\\\n    function _msgData() internal view virtual returns (bytes calldata) {\\\\n        return msg.data;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\\\n     * variables without shifting down storage in the inheritance chain.\\\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\\\n     */\\\\n    uint256[50] private __gap;\\\\n}\\\\n\\\"},\\\"lib/osx/packages/contracts/src/core/utils/auth.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\n\\\\npragma solidity ^0.8.8;\\\\n\\\\nimport {IDAO} from \\\\\\\"../dao/IDAO.sol\\\\\\\";\\\\n\\\\n/// @notice Thrown if a call is unauthorized in the associated DAO.\\\\n/// @param dao The associated DAO.\\\\n/// @param where The context in which the authorization reverted.\\\\n/// @param who The address (EOA or contract) missing the permission.\\\\n/// @param permissionId The permission identifier.\\\\nerror DaoUnauthorized(address dao, address where, address who, bytes32 permissionId);\\\\n\\\\n/// @notice A free function checking if a caller is granted permissions on a target contract via a permission identifier that redirects the approval to a `PermissionCondition` if this was specified in the setup.\\\\n/// @param _where The address of the target contract for which `who` receives permission.\\\\n/// @param _who The address (EOA or contract) owning the permission.\\\\n/// @param _permissionId The permission identifier.\\\\n/// @param _data The optional data passed to the `PermissionCondition` registered.\\\\nfunction _auth(\\\\n    IDAO _dao,\\\\n    address _where,\\\\n    address _who,\\\\n    bytes32 _permissionId,\\\\n    bytes calldata _data\\\\n) view {\\\\n    if (!_dao.hasPermission(_where, _who, _permissionId, _data))\\\\n        revert DaoUnauthorized({\\\\n            dao: address(_dao),\\\\n            where: _where,\\\\n            who: _who,\\\\n            permissionId: _permissionId\\\\n        });\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\\\n */\\\\ninterface IBeaconUpgradeable {\\\\n    /**\\\\n     * @dev Must return an address that can be used as a delegate call target.\\\\n     *\\\\n     * {BeaconProxy} will check that this address is a contract.\\\\n     */\\\\n    function implementation() external view returns (address);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1967Upgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\\\n *\\\\n * _Available since v4.8.3._\\\\n */\\\\ninterface IERC1967Upgradeable {\\\\n    /**\\\\n     * @dev Emitted when the implementation is upgraded.\\\\n     */\\\\n    event Upgraded(address indexed implementation);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the admin account has changed.\\\\n     */\\\\n    event AdminChanged(address previousAdmin, address newAdmin);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the beacon is changed.\\\\n     */\\\\n    event BeaconUpgraded(address indexed beacon);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Library for reading and writing primitive types to specific storage slots.\\\\n *\\\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\\\n *\\\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\\\n *\\\\n * Example usage to set ERC1967 implementation slot:\\\\n * ```solidity\\\\n * contract ERC1967 {\\\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\\\n *\\\\n *     function _getImplementation() internal view returns (address) {\\\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\\\n *     }\\\\n *\\\\n *     function _setImplementation(address newImplementation) internal {\\\\n *         require(Address.isContract(newImplementation), \\\\\\\"ERC1967: new implementation is not a contract\\\\\\\");\\\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\\\n *     }\\\\n * }\\\\n * ```\\\\n *\\\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\\\n * _Available since v4.9 for `string`, `bytes`._\\\\n */\\\\nlibrary StorageSlotUpgradeable {\\\\n    struct AddressSlot {\\\\n        address value;\\\\n    }\\\\n\\\\n    struct BooleanSlot {\\\\n        bool value;\\\\n    }\\\\n\\\\n    struct Bytes32Slot {\\\\n        bytes32 value;\\\\n    }\\\\n\\\\n    struct Uint256Slot {\\\\n        uint256 value;\\\\n    }\\\\n\\\\n    struct StringSlot {\\\\n        string value;\\\\n    }\\\\n\\\\n    struct BytesSlot {\\\\n        bytes value;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\\\n     */\\\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\\\n     */\\\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\\\n     */\\\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\\\n     */\\\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\\\n     */\\\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\\\n     */\\\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := store.slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\\\n     */\\\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\\\n     */\\\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := store.slot\\\\n        }\\\\n    }\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\\\n */\\\\ninterface IBeacon {\\\\n    /**\\\\n     * @dev Must return an address that can be used as a delegate call target.\\\\n     *\\\\n     * {BeaconProxy} will check that this address is a contract.\\\\n     */\\\\n    function implementation() external view returns (address);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\\\n *\\\\n * _Available since v4.8.3._\\\\n */\\\\ninterface IERC1967 {\\\\n    /**\\\\n     * @dev Emitted when the implementation is upgraded.\\\\n     */\\\\n    event Upgraded(address indexed implementation);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the admin account has changed.\\\\n     */\\\\n    event AdminChanged(address previousAdmin, address newAdmin);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the beacon is changed.\\\\n     */\\\\n    event BeaconUpgraded(address indexed beacon);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\\\n * proxy whose upgrades are fully controlled by the current implementation.\\\\n */\\\\ninterface IERC1822Proxiable {\\\\n    /**\\\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\\\n     * address.\\\\n     *\\\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\\\n     * function revert if invoked through a proxy.\\\\n     */\\\\n    function proxiableUUID() external view returns (bytes32);\\\\n}\\\\n\\\"},\\\"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\\\":{\\\"content\\\":\\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Library for reading and writing primitive types to specific storage slots.\\\\n *\\\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\\\n *\\\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\\\n *\\\\n * Example usage to set ERC1967 implementation slot:\\\\n * ```solidity\\\\n * contract ERC1967 {\\\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\\\n *\\\\n *     function _getImplementation() internal view returns (address) {\\\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\\\n *     }\\\\n *\\\\n *     function _setImplementation(address newImplementation) internal {\\\\n *         require(Address.isContract(newImplementation), \\\\\\\"ERC1967: new implementation is not a contract\\\\\\\");\\\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\\\n *     }\\\\n * }\\\\n * ```\\\\n *\\\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\\\n * _Available since v4.9 for `string`, `bytes`._\\\\n */\\\\nlibrary StorageSlot {\\\\n    struct AddressSlot {\\\\n        address value;\\\\n    }\\\\n\\\\n    struct BooleanSlot {\\\\n        bool value;\\\\n    }\\\\n\\\\n    struct Bytes32Slot {\\\\n        bytes32 value;\\\\n    }\\\\n\\\\n    struct Uint256Slot {\\\\n        uint256 value;\\\\n    }\\\\n\\\\n    struct StringSlot {\\\\n        string value;\\\\n    }\\\\n\\\\n    struct BytesSlot {\\\\n        bytes value;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\\\n     */\\\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\\\n     */\\\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\\\n     */\\\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\\\n     */\\\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\\\n     */\\\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\\\n     */\\\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := store.slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\\\n     */\\\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := slot\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\\\n     */\\\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\\\n        /// @solidity memory-safe-assembly\\\\n        assembly {\\\\n            r.slot := store.slot\\\\n        }\\\\n    }\\\\n}\\\\n\\\"}},\\\"settings\\\":{\\\"remappings\\\":[\\\"ds-test/=lib/ds-test/src/\\\",\\\"forge-std/=lib/forge-std/src/\\\",\\\"utils/=test/utils/\\\",\\\"@aragon/osx/=lib/osx/packages/contracts/src/\\\",\\\"@aragon/admin/=lib/osx/packages/contracts/src/plugins/governance/admin/\\\",\\\"@aragon/multisig/=lib/osx/packages/contracts/src/plugins/governance/multisig/\\\",\\\"@interfaces/=src/interfaces/\\\",\\\"@mocks/=test/mocks/\\\",\\\"@libs/=src/libs/\\\",\\\"@utils/=src/utils/\\\",\\\"@helpers/=test/helpers/\\\",\\\"@clock/=src/clock/\\\",\\\"@ensdomains/ens-contracts/=lib/ens-contracts/\\\",\\\"ens-contracts/=lib/ens-contracts/contracts/\\\",\\\"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\\\",\\\"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\\\",\\\"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\\\",\\\"openzeppelin-contracts/=lib/openzeppelin-contracts/\\\",\\\"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\\\",\\\"@solmate/=lib/solmate/src/\\\",\\\"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\\\",\\\"osx/=lib/osx/\\\",\\\"solmate/=lib/solmate/src/\\\"],\\\"optimizer\\\":{\\\"enabled\\\":true,\\\"runs\\\":200},\\\"metadata\\\":{\\\"useLiteralContent\\\":false,\\\"bytecodeHash\\\":\\\"ipfs\\\"},\\\"outputSelection\\\":{\\\"*\\\":{\\\"*\\\":[\\\"abi\\\",\\\"evm.bytecode.object\\\",\\\"evm.bytecode.sourceMap\\\",\\\"evm.bytecode.linkReferences\\\",\\\"evm.deployedBytecode.object\\\",\\\"evm.deployedBytecode.sourceMap\\\",\\\"evm.deployedBytecode.linkReferences\\\",\\\"evm.deployedBytecode.immutableReferences\\\",\\\"evm.methodIdentifiers\\\",\\\"metadata\\\"]}},\\\"evmVersion\\\":\\\"london\\\",\\\"viaIR\\\":false,\\\"libraries\\\":{}}}\",\"codeformat\":\"solidity-standard-json-input\",\"contractname\":\"src/setup/PaymentsPluginSetup.sol:PaymentsPluginSetup\",\"compilerversion\":\"v0.8.17+commit.8df45f5f\",\"constructorArguements\":\"\",\"constructorArguments\":\"\"}"

Submitting verification for [src/setup/PaymentsPluginSetup.sol:PaymentsPluginSetup] 0x107537B35Ec8D98721bfAEF421346D10174263ba.
Submitted contract for verification:
	Response: `OK`
	GUID: `fuf1m5x25h69el4pihzz3nymiykadykv5cch8msgik6yeaxzsk`
	URL: https://sepolia.etherscan.io/address/0x107537b35ec8d98721bfaef421346d10174263ba
Contract verification status:
Response: `NOTOK`
Details: `Pending in queue`
Contract verification status:
Response: `OK`
Details: `Pass - Verified`
Contract successfully verified
Start verifying contract `0x2061aF6031452943cf65987AC37F80F69236f10f` deployed on sepolia
Compiler version: 0.8.17
Optimizations:    200

Submitting verification for [src/PaymentsPlugin.sol:PaymentsPlugin] 0x2061aF6031452943cf65987AC37F80F69236f10f.
Submitted contract for verification:
	Response: `OK`
	GUID: `aplzwhwuhnjnnywb5s9mgmqirhh1991kjtywkxgjkffdxmxzb4`
	URL: https://sepolia.etherscan.io/address/0x2061af6031452943cf65987ac37f80f69236f10f
Contract verification status:
Response: `NOTOK`
Details: `Pending in queue`
